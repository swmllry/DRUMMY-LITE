{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;\n\nconst whatwg_url_1 = require(\"whatwg-url\");\n\nconst redact_1 = require(\"./redact\");\n\nObject.defineProperty(exports, \"redactConnectionString\", {\n  enumerable: true,\n  get: function () {\n    return redact_1.redactConnectionString;\n  }\n});\nconst DUMMY_HOSTNAME = '__this_is_a_placeholder__';\n\nfunction connectionStringHasValidScheme(connectionString) {\n  return connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://');\n}\n\nconst HOSTS_REGEX = /^(?<protocol>[^/]+):\\/\\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;\n\nclass CaseInsensitiveMap extends Map {\n  delete(name) {\n    return super.delete(this._normalizeKey(name));\n  }\n\n  get(name) {\n    return super.get(this._normalizeKey(name));\n  }\n\n  has(name) {\n    return super.has(this._normalizeKey(name));\n  }\n\n  set(name, value) {\n    return super.set(this._normalizeKey(name), value);\n  }\n\n  _normalizeKey(name) {\n    name = `${name}`;\n\n    for (const key of this.keys()) {\n      if (key.toLowerCase() === name.toLowerCase()) {\n        name = key;\n        break;\n      }\n    }\n\n    return name;\n  }\n\n}\n\nfunction caseInsenstiveURLSearchParams(Ctor) {\n  return class CaseInsenstiveURLSearchParams extends Ctor {\n    append(name, value) {\n      return super.append(this._normalizeKey(name), value);\n    }\n\n    delete(name) {\n      return super.delete(this._normalizeKey(name));\n    }\n\n    get(name) {\n      return super.get(this._normalizeKey(name));\n    }\n\n    getAll(name) {\n      return super.getAll(this._normalizeKey(name));\n    }\n\n    has(name) {\n      return super.has(this._normalizeKey(name));\n    }\n\n    set(name, value) {\n      return super.set(this._normalizeKey(name), value);\n    }\n\n    keys() {\n      return super.keys();\n    }\n\n    values() {\n      return super.values();\n    }\n\n    entries() {\n      return super.entries();\n    }\n\n    [Symbol.iterator]() {\n      return super[Symbol.iterator]();\n    }\n\n    _normalizeKey(name) {\n      return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);\n    }\n\n  };\n}\n\nclass URLWithoutHost extends whatwg_url_1.URL {}\n\nclass MongoParseError extends Error {\n  get name() {\n    return 'MongoParseError';\n  }\n\n}\n\nclass ConnectionString extends URLWithoutHost {\n  constructor(uri) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    const {\n      looseValidation\n    } = options;\n\n    if (!looseValidation && !connectionStringHasValidScheme(uri)) {\n      throw new MongoParseError('Invalid scheme, expected connection string to start with \"mongodb://\" or \"mongodb+srv://\"');\n    }\n\n    const match = uri.match(HOSTS_REGEX);\n\n    if (!match) {\n      throw new MongoParseError(`Invalid connection string \"${uri}\"`);\n    }\n\n    const {\n      protocol,\n      username,\n      password,\n      hosts,\n      rest\n    } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};\n\n    if (!looseValidation) {\n      if (!protocol || !hosts) {\n        throw new MongoParseError(`Protocol and host list are required in \"${uri}\"`);\n      }\n\n      try {\n        decodeURIComponent(username !== null && username !== void 0 ? username : '');\n        decodeURIComponent(password !== null && password !== void 0 ? password : '');\n      } catch (err) {\n        throw new MongoParseError(err.message);\n      }\n\n      const illegalCharacters = /[:/?#[\\]@]/gi;\n\n      if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {\n        throw new MongoParseError(`Username contains unescaped characters ${username}`);\n      }\n\n      if (!username || !password) {\n        const uriWithoutProtocol = uri.replace(`${protocol}://`, '');\n\n        if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {\n          throw new MongoParseError('URI contained empty userinfo section');\n        }\n      }\n\n      if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {\n        throw new MongoParseError('Password contains unescaped characters');\n      }\n    }\n\n    let authString = '';\n    if (typeof username === 'string') authString += username;\n    if (typeof password === 'string') authString += `:${password}`;\n    if (authString) authString += '@';\n\n    try {\n      super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);\n    } catch (err) {\n      if (looseValidation) {\n        new ConnectionString(uri, { ...options,\n          looseValidation: false\n        });\n      }\n\n      if (typeof err.message === 'string') {\n        err.message = err.message.replace(DUMMY_HOSTNAME, hosts);\n      }\n\n      throw err;\n    }\n\n    this._hosts = hosts.split(',');\n\n    if (!looseValidation) {\n      if (this.isSRV && this.hosts.length !== 1) {\n        throw new MongoParseError('mongodb+srv URI cannot have multiple service names');\n      }\n\n      if (this.isSRV && this.hosts.some(host => host.includes(':'))) {\n        throw new MongoParseError('mongodb+srv URI cannot have port number');\n      }\n    }\n\n    if (!this.pathname) {\n      this.pathname = '/';\n    }\n\n    Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);\n  }\n\n  get host() {\n    return DUMMY_HOSTNAME;\n  }\n\n  set host(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get hostname() {\n    return DUMMY_HOSTNAME;\n  }\n\n  set hostname(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get port() {\n    return '';\n  }\n\n  set port(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get href() {\n    return this.toString();\n  }\n\n  set href(_ignored) {\n    throw new Error('Cannot set href for connection strings');\n  }\n\n  get isSRV() {\n    return this.protocol.includes('srv');\n  }\n\n  get hosts() {\n    return this._hosts;\n  }\n\n  set hosts(list) {\n    this._hosts = list;\n  }\n\n  toString() {\n    return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(','));\n  }\n\n  clone() {\n    return new ConnectionString(this.toString(), {\n      looseValidation: true\n    });\n  }\n\n  redact(options) {\n    return (0, redact_1.redactValidConnectionString)(this, options);\n  }\n\n  typedSearchParams() {\n    const sametype = false && new (caseInsenstiveURLSearchParams(whatwg_url_1.URLSearchParams))();\n    return this.searchParams;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    const {\n      href,\n      origin,\n      protocol,\n      username,\n      password,\n      hosts,\n      pathname,\n      search,\n      searchParams,\n      hash\n    } = this;\n    return {\n      href,\n      origin,\n      protocol,\n      username,\n      password,\n      hosts,\n      pathname,\n      search,\n      searchParams,\n      hash\n    };\n  }\n\n}\n\nexports.ConnectionString = ConnectionString;\n\nclass CommaAndColonSeparatedRecord extends CaseInsensitiveMap {\n  constructor(from) {\n    super();\n\n    for (const entry of (from !== null && from !== void 0 ? from : '').split(',')) {\n      if (!entry) continue;\n      const colonIndex = entry.indexOf(':');\n\n      if (colonIndex === -1) {\n        this.set(entry, '');\n      } else {\n        this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));\n      }\n    }\n  }\n\n  toString() {\n    return [...this].map(entry => entry.join(':')).join(',');\n  }\n\n}\n\nexports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;\nexports.default = ConnectionString;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;\nconst whatwg_url_1 = require(\"whatwg-url\");\nconst redact_1 = require(\"./redact\");\nObject.defineProperty(exports, \"redactConnectionString\", { enumerable: true, get: function () { return redact_1.redactConnectionString; } });\nconst DUMMY_HOSTNAME = '__this_is_a_placeholder__';\nfunction connectionStringHasValidScheme(connectionString) {\n    return (connectionString.startsWith('mongodb://') ||\n        connectionString.startsWith('mongodb+srv://'));\n}\nconst HOSTS_REGEX = /^(?<protocol>[^/]+):\\/\\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;\nclass CaseInsensitiveMap extends Map {\n    delete(name) {\n        return super.delete(this._normalizeKey(name));\n    }\n    get(name) {\n        return super.get(this._normalizeKey(name));\n    }\n    has(name) {\n        return super.has(this._normalizeKey(name));\n    }\n    set(name, value) {\n        return super.set(this._normalizeKey(name), value);\n    }\n    _normalizeKey(name) {\n        name = `${name}`;\n        for (const key of this.keys()) {\n            if (key.toLowerCase() === name.toLowerCase()) {\n                name = key;\n                break;\n            }\n        }\n        return name;\n    }\n}\nfunction caseInsenstiveURLSearchParams(Ctor) {\n    return class CaseInsenstiveURLSearchParams extends Ctor {\n        append(name, value) {\n            return super.append(this._normalizeKey(name), value);\n        }\n        delete(name) {\n            return super.delete(this._normalizeKey(name));\n        }\n        get(name) {\n            return super.get(this._normalizeKey(name));\n        }\n        getAll(name) {\n            return super.getAll(this._normalizeKey(name));\n        }\n        has(name) {\n            return super.has(this._normalizeKey(name));\n        }\n        set(name, value) {\n            return super.set(this._normalizeKey(name), value);\n        }\n        keys() {\n            return super.keys();\n        }\n        values() {\n            return super.values();\n        }\n        entries() {\n            return super.entries();\n        }\n        [Symbol.iterator]() {\n            return super[Symbol.iterator]();\n        }\n        _normalizeKey(name) {\n            return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);\n        }\n    };\n}\nclass URLWithoutHost extends whatwg_url_1.URL {\n}\nclass MongoParseError extends Error {\n    get name() {\n        return 'MongoParseError';\n    }\n}\nclass ConnectionString extends URLWithoutHost {\n    constructor(uri, options = {}) {\n        var _a;\n        const { looseValidation } = options;\n        if (!looseValidation && !connectionStringHasValidScheme(uri)) {\n            throw new MongoParseError('Invalid scheme, expected connection string to start with \"mongodb://\" or \"mongodb+srv://\"');\n        }\n        const match = uri.match(HOSTS_REGEX);\n        if (!match) {\n            throw new MongoParseError(`Invalid connection string \"${uri}\"`);\n        }\n        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};\n        if (!looseValidation) {\n            if (!protocol || !hosts) {\n                throw new MongoParseError(`Protocol and host list are required in \"${uri}\"`);\n            }\n            try {\n                decodeURIComponent(username !== null && username !== void 0 ? username : '');\n                decodeURIComponent(password !== null && password !== void 0 ? password : '');\n            }\n            catch (err) {\n                throw new MongoParseError(err.message);\n            }\n            const illegalCharacters = /[:/?#[\\]@]/gi;\n            if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {\n                throw new MongoParseError(`Username contains unescaped characters ${username}`);\n            }\n            if (!username || !password) {\n                const uriWithoutProtocol = uri.replace(`${protocol}://`, '');\n                if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {\n                    throw new MongoParseError('URI contained empty userinfo section');\n                }\n            }\n            if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {\n                throw new MongoParseError('Password contains unescaped characters');\n            }\n        }\n        let authString = '';\n        if (typeof username === 'string')\n            authString += username;\n        if (typeof password === 'string')\n            authString += `:${password}`;\n        if (authString)\n            authString += '@';\n        try {\n            super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);\n        }\n        catch (err) {\n            if (looseValidation) {\n                new ConnectionString(uri, {\n                    ...options,\n                    looseValidation: false\n                });\n            }\n            if (typeof err.message === 'string') {\n                err.message = err.message.replace(DUMMY_HOSTNAME, hosts);\n            }\n            throw err;\n        }\n        this._hosts = hosts.split(',');\n        if (!looseValidation) {\n            if (this.isSRV && this.hosts.length !== 1) {\n                throw new MongoParseError('mongodb+srv URI cannot have multiple service names');\n            }\n            if (this.isSRV && this.hosts.some(host => host.includes(':'))) {\n                throw new MongoParseError('mongodb+srv URI cannot have port number');\n            }\n        }\n        if (!this.pathname) {\n            this.pathname = '/';\n        }\n        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);\n    }\n    get host() { return DUMMY_HOSTNAME; }\n    set host(_ignored) { throw new Error('No single host for connection string'); }\n    get hostname() { return DUMMY_HOSTNAME; }\n    set hostname(_ignored) { throw new Error('No single host for connection string'); }\n    get port() { return ''; }\n    set port(_ignored) { throw new Error('No single host for connection string'); }\n    get href() { return this.toString(); }\n    set href(_ignored) { throw new Error('Cannot set href for connection strings'); }\n    get isSRV() {\n        return this.protocol.includes('srv');\n    }\n    get hosts() {\n        return this._hosts;\n    }\n    set hosts(list) {\n        this._hosts = list;\n    }\n    toString() {\n        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(','));\n    }\n    clone() {\n        return new ConnectionString(this.toString(), {\n            looseValidation: true\n        });\n    }\n    redact(options) {\n        return (0, redact_1.redactValidConnectionString)(this, options);\n    }\n    typedSearchParams() {\n        const sametype = false && new (caseInsenstiveURLSearchParams(whatwg_url_1.URLSearchParams))();\n        return this.searchParams;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;\n        return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };\n    }\n}\nexports.ConnectionString = ConnectionString;\nclass CommaAndColonSeparatedRecord extends CaseInsensitiveMap {\n    constructor(from) {\n        super();\n        for (const entry of (from !== null && from !== void 0 ? from : '').split(',')) {\n            if (!entry)\n                continue;\n            const colonIndex = entry.indexOf(':');\n            if (colonIndex === -1) {\n                this.set(entry, '');\n            }\n            else {\n                this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));\n            }\n        }\n    }\n    toString() {\n        return [...this].map(entry => entry.join(':')).join(',');\n    }\n}\nexports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;\nexports.default = ConnectionString;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}