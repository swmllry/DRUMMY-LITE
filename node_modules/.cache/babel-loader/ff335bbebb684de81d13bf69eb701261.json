{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nexports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst os = require(\"os\");\n\nconst timers_1 = require(\"timers\");\n\nconst url_1 = require(\"url\");\n\nconst bson_1 = require(\"./bson\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nconst constants_2 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\n\nfunction parseIndexOptions(indexSpec) {\n  const fieldHash = {};\n  const indexes = [];\n  let keys; // Get all the fields accordingly\n\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(f => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(_ref => {\n      let [key, value] = _ref;\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\nexports.parseIndexOptions = parseIndexOptions;\n\nconst TO_STRING = object => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\n\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  var _a;\n\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\n\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    } // interrupt the function call with a warning\n\n\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n\n    return fn.bind(this)(...args);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection === '' ? undefined : collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter() {\n  let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\n\nfunction maybePromise(callback, wrapper) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    callback(err, res);\n  });\n  return result;\n}\n\nexports.maybePromise = maybePromise;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\n\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let cannotBeExpedited = false;\n  let stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const nextScheduledCallTime = lastCallTime + interval;\n    const timeUntilNextCall = nextScheduledCallTime - currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n      return;\n    } // debounce multiple calls to wake within the `minInterval`\n\n\n    if (cannotBeExpedited) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n      cannotBeExpedited = true;\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      (0, timers_1.clearTimeout)(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    cannotBeExpedited = false;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n\n    if (timerId) {\n      (0, timers_1.clearTimeout)(timerId);\n    }\n\n    timerId = (0, timers_1.setTimeout)(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    cannotBeExpedited = false;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options === null || options === void 0 ? void 0 : options.session;\n\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\n\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\n\nfunction isRecord(value) {\n  let requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/** @internal */\n\nconst kBuffers = Symbol('buffers');\n/** @internal */\n\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  get length() {\n    return this[kLength];\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n  /** Returns the requested number of bytes without consuming them */\n\n\n  peek(size) {\n    return this.read(size, false);\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size) {\n    let consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n\n    let result; // read the whole buffer\n\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    } // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    } // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n\n          offset += bytesCopied;\n          break;\n        }\n\n        bytesToCopy -= bytesCopied;\n      } // compact the internal buffer array\n\n\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    const {\n      hostname,\n      port\n    } = new url_1.URL(`mongodb://${escapedHost}`);\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n\n  inspect() {\n    return `new HostAddress('${this.toString(true)}')`;\n  }\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n\n\n  toString() {\n    let ipv6Brackets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host, port) {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord(_ref2) {\n    let {\n      name,\n      port\n    } = _ref2;\n    return HostAddress.fromHostPort(name, port);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n\nfunction parsePackageVersion(_ref3) {\n  let {\n    version\n  } = _ref3;\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\n\nexports.parsePackageVersion = parsePackageVersion;\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\n\nfunction shuffle(sequence) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1; // And swap it with the current element\n\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\nexports.shuffle = shuffle; // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\n\nfunction getMongoDBClientEncryption() {\n  let mongodbClientEncryption = null; // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n\n  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n    } catch {// ignore\n    }\n  } else {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require('mongodb-client-encryption');\n    } catch {// ignore\n    }\n  }\n\n  return mongodbClientEncryption;\n}\n\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nexports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = void 0;\nconst crypto = require(\"crypto\");\nconst os = require(\"os\");\nconst timers_1 = require(\"timers\");\nconst url_1 = require(\"url\");\nconst bson_1 = require(\"./bson\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nconst constants_2 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst write_concern_1 = require(\"./write_concern\");\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nfunction checkCollectionName(collectionName) {\n    if ('string' !== typeof collectionName) {\n        throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n    }\n    if (!collectionName || collectionName.indexOf('..') !== -1) {\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n    }\n    if (collectionName.indexOf('$') !== -1 &&\n        collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n    }\n    if (collectionName.match(/^\\.|\\.$/) != null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n    }\n    // Validate that we are not passing 0x00 in the collection name\n    if (collectionName.indexOf('\\x00') !== -1) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n    }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n    let finalHint = undefined;\n    if (typeof hint === 'string') {\n        finalHint = hint;\n    }\n    else if (Array.isArray(hint)) {\n        finalHint = {};\n        hint.forEach(param => {\n            finalHint[param] = 1;\n        });\n    }\n    else if (hint != null && typeof hint === 'object') {\n        finalHint = {};\n        for (const name in hint) {\n            finalHint[name] = hint[name];\n        }\n    }\n    return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\nfunction parseIndexOptions(indexSpec) {\n    const fieldHash = {};\n    const indexes = [];\n    let keys;\n    // Get all the fields accordingly\n    if ('string' === typeof indexSpec) {\n        // 'type'\n        indexes.push(indexSpec + '_' + 1);\n        fieldHash[indexSpec] = 1;\n    }\n    else if (Array.isArray(indexSpec)) {\n        indexSpec.forEach((f) => {\n            if ('string' === typeof f) {\n                // [{location:'2d'}, 'type']\n                indexes.push(f + '_' + 1);\n                fieldHash[f] = 1;\n            }\n            else if (Array.isArray(f)) {\n                // [['location', '2d'],['type', 1]]\n                indexes.push(f[0] + '_' + (f[1] || 1));\n                fieldHash[f[0]] = f[1] || 1;\n            }\n            else if (isObject(f)) {\n                // [{location:'2d'}, {type:1}]\n                keys = Object.keys(f);\n                keys.forEach(k => {\n                    indexes.push(k + '_' + f[k]);\n                    fieldHash[k] = f[k];\n                });\n            }\n            else {\n                // undefined (ignore)\n            }\n        });\n    }\n    else if (isObject(indexSpec)) {\n        // {location:'2d', type:1}\n        keys = Object.keys(indexSpec);\n        Object.entries(indexSpec).forEach(([key, value]) => {\n            indexes.push(key + '_' + value);\n            fieldHash[key] = value;\n        });\n    }\n    return {\n        name: indexes.join('_'),\n        keys: keys,\n        fieldHash: fieldHash\n    };\n}\nexports.parseIndexOptions = parseIndexOptions;\nconst TO_STRING = (object) => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\nfunction isObject(arg) {\n    return '[object Object]' === TO_STRING(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction mergeOptions(target, source) {\n    return { ...target, ...source };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n    const filterOptions = {};\n    for (const name in options) {\n        if (names.includes(name)) {\n            filterOptions[name] = options[name];\n        }\n    }\n    // Filtered options\n    return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n    var _a;\n    if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n        target.retryWrites = true;\n    }\n    return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nfunction applyWriteConcern(target, sources, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const db = sources.db;\n    const coll = sources.collection;\n    if (options.session && options.session.inTransaction()) {\n        // writeConcern is not allowed within a multi-statement transaction\n        if (target.writeConcern) {\n            delete target.writeConcern;\n        }\n        return target;\n    }\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    if (writeConcern) {\n        return Object.assign(target, { writeConcern });\n    }\n    if (coll && coll.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n    }\n    if (db && db.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n    }\n    return target;\n}\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n    return !!maybePromise && typeof maybePromise.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n    const capabilities = getTopology(target).capabilities;\n    if (options.collation && typeof options.collation === 'object') {\n        if (capabilities && capabilities.commandsTakeCollation) {\n            command.collation = options.collation;\n        }\n        else {\n            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n        }\n    }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n    if (options && options.session && options.session.inTransaction()) {\n        return;\n    }\n    const readConcern = Object.assign({}, command.readConcern || {});\n    if (coll.s.readConcern) {\n        Object.assign(readConcern, coll.s.readConcern);\n    }\n    if (Object.keys(readConcern).length > 0) {\n        Object.assign(command, { readConcern: readConcern });\n    }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n    if (command.explain) {\n        return command;\n    }\n    return { explain: command, verbosity: explain.verbosity };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\nfunction getTopology(provider) {\n    // MongoClient or ClientSession or AbstractCursor\n    if ('topology' in provider && provider.topology) {\n        return provider.topology;\n    }\n    else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n        return provider.s.client.topology;\n    }\n    else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n        return provider.s.db.s.client.topology;\n    }\n    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\nfunction defaultMsgHandler(name, option) {\n    return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\nfunction deprecateOptions(config, fn) {\n    if (process.noDeprecation === true) {\n        return fn;\n    }\n    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n    const optionsWarned = new Set();\n    function deprecated(...args) {\n        const options = args[config.optionsIndex];\n        // ensure options is a valid, non-empty object, otherwise short-circuit\n        if (!isObject(options) || Object.keys(options).length === 0) {\n            return fn.bind(this)(...args); // call the function, no change\n        }\n        // interrupt the function call with a warning\n        for (const deprecatedOption of config.deprecatedOptions) {\n            if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n                optionsWarned.add(deprecatedOption);\n                const msg = msgHandler(config.name, deprecatedOption);\n                emitWarning(msg);\n                if (this && 'getLogger' in this) {\n                    const logger = this.getLogger();\n                    if (logger) {\n                        logger.warn(msg);\n                    }\n                }\n            }\n        }\n        return fn.bind(this)(...args);\n    }\n    // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n    // The wrapper will keep the same prototype as fn to maintain prototype chain\n    Object.setPrototypeOf(deprecated, fn);\n    if (fn.prototype) {\n        // Setting this (rather than using Object.setPrototype, as above) ensures\n        // that calling the unwrapped constructor gives an instanceof the wrapped\n        // constructor.\n        deprecated.prototype = fn.prototype;\n    }\n    return deprecated;\n}\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\nfunction ns(ns) {\n    return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n    /**\n     * Create a namespace object\n     *\n     * @param db - database name\n     * @param collection - collection name\n     */\n    constructor(db, collection) {\n        this.db = db;\n        this.collection = collection === '' ? undefined : collection;\n    }\n    toString() {\n        return this.collection ? `${this.db}.${this.collection}` : this.db;\n    }\n    withCollection(collection) {\n        return new MongoDBNamespace(this.db, collection);\n    }\n    static fromString(namespace) {\n        if (typeof namespace !== 'string' || namespace === '') {\n            // TODO(NODE-3483): Replace with MongoNamespaceError\n            throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n        }\n        const [db, ...collectionParts] = namespace.split('.');\n        const collection = collectionParts.join('.');\n        return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n    }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction* makeCounter(seed = 0) {\n    let count = seed;\n    while (true) {\n        const newCount = count;\n        count += 1;\n        yield newCount;\n    }\n}\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(callback, wrapper) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    let result;\n    if (typeof callback !== 'function') {\n        result = new Promise((resolve, reject) => {\n            callback = (err, res) => {\n                if (err)\n                    return reject(err);\n                resolve(res);\n            };\n        });\n    }\n    wrapper((err, res) => {\n        if (err != null) {\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                callback(err);\n            }\n            catch (error) {\n                process.nextTick(() => {\n                    throw error;\n                });\n            }\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err, res);\n    });\n    return result;\n}\nexports.maybePromise = maybePromise;\n/** @internal */\nfunction databaseNamespace(ns) {\n    return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n    const result = crypto.randomBytes(16);\n    result[6] = (result[6] & 0x0f) | 0x40;\n    result[8] = (result[8] & 0x3f) | 0x80;\n    return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n    if (topologyOrServer) {\n        if (topologyOrServer.loadBalanced) {\n            // Since we do not have a monitor, we assume the load balanced server is always\n            // pointed at the latest mongodb version. There is a risk that for on-prem\n            // deployments that don't upgrade immediately that this could alert to the\n            // application that a feature is avaiable that is actually not.\n            return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n        }\n        if (topologyOrServer.hello) {\n            return topologyOrServer.hello.maxWireVersion;\n        }\n        if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n            const lastHello = topologyOrServer.lastHello();\n            if (lastHello) {\n                return lastHello.maxWireVersion;\n            }\n        }\n        if (topologyOrServer.description &&\n            'maxWireVersion' in topologyOrServer.description &&\n            topologyOrServer.description.maxWireVersion != null) {\n            return topologyOrServer.description.maxWireVersion;\n        }\n    }\n    return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\nfunction collationNotSupported(server, cmd) {\n    return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = 0;\n    for (idx = 0; idx < arr.length; ++idx) {\n        awaiting++;\n        eachFn(arr[idx], eachCallback);\n    }\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n        }\n    }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction eachAsyncSeries(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = arr.length;\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        idx++;\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n            return;\n        }\n        eachFn(arr[idx], eachCallback);\n    }\n    eachFn(arr[idx], eachCallback);\n}\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n    if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n        return false;\n    }\n    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n    if (lhs === rhs) {\n        return true;\n    }\n    if (!lhs || !rhs) {\n        return lhs === rhs;\n    }\n    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n        return false;\n    }\n    if (lhs.constructor.name !== rhs.constructor.name) {\n        return false;\n    }\n    if (lhs.message !== rhs.message) {\n        return false;\n    }\n    return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n    return function stateTransition(target, newState) {\n        const legalStates = stateTable[target.s.state];\n        if (legalStates && legalStates.indexOf(newState) < 0) {\n            throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n        }\n        target.emit('stateChanged', target.s.state, newState);\n        target.s.state = newState;\n    };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const metadata = {\n        driver: {\n            name: 'nodejs',\n            version: NODE_DRIVER_VERSION\n        },\n        os: {\n            type: os.type(),\n            name: process.platform,\n            architecture: process.arch,\n            version: os.release()\n        },\n        platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n    };\n    // support optionally provided wrapping driver info\n    if (options.driverInfo) {\n        if (options.driverInfo.name) {\n            metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n        }\n        if (options.driverInfo.version) {\n            metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n        }\n        if (options.driverInfo.platform) {\n            metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n        }\n    }\n    if (options.appName) {\n        // MongoDB requires the appName not exceed a byte length of 128\n        const buffer = Buffer.from(options.appName);\n        metadata.application = {\n            name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n        };\n    }\n    return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n    const hrtime = process.hrtime();\n    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n    if (typeof started !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n    }\n    const elapsed = now() - started;\n    return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\nfunction makeInterruptibleAsyncInterval(fn, options) {\n    let timerId;\n    let lastCallTime;\n    let cannotBeExpedited = false;\n    let stopped = false;\n    options = options !== null && options !== void 0 ? options : {};\n    const interval = options.interval || 1000;\n    const minInterval = options.minInterval || 500;\n    const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n    const clock = typeof options.clock === 'function' ? options.clock : now;\n    function wake() {\n        const currentTime = clock();\n        const nextScheduledCallTime = lastCallTime + interval;\n        const timeUntilNextCall = nextScheduledCallTime - currentTime;\n        // For the streaming protocol: there is nothing obviously stopping this\n        // interval from being woken up again while we are waiting \"infinitely\"\n        // for `fn` to be called again`. Since the function effectively\n        // never completes, the `timeUntilNextCall` will continue to grow\n        // negatively unbounded, so it will never trigger a reschedule here.\n        // This is possible in virtualized environments like AWS Lambda where our\n        // clock is unreliable. In these cases the timer is \"running\" but never\n        // actually completes, so we want to execute immediately and then attempt\n        // to reschedule.\n        if (timeUntilNextCall < 0) {\n            executeAndReschedule();\n            return;\n        }\n        // debounce multiple calls to wake within the `minInterval`\n        if (cannotBeExpedited) {\n            return;\n        }\n        // reschedule a call as soon as possible, ensuring the call never happens\n        // faster than the `minInterval`\n        if (timeUntilNextCall > minInterval) {\n            reschedule(minInterval);\n            cannotBeExpedited = true;\n        }\n    }\n    function stop() {\n        stopped = true;\n        if (timerId) {\n            (0, timers_1.clearTimeout)(timerId);\n            timerId = undefined;\n        }\n        lastCallTime = 0;\n        cannotBeExpedited = false;\n    }\n    function reschedule(ms) {\n        if (stopped)\n            return;\n        if (timerId) {\n            (0, timers_1.clearTimeout)(timerId);\n        }\n        timerId = (0, timers_1.setTimeout)(executeAndReschedule, ms || interval);\n    }\n    function executeAndReschedule() {\n        cannotBeExpedited = false;\n        lastCallTime = clock();\n        fn(err => {\n            if (err)\n                throw err;\n            reschedule(interval);\n        });\n    }\n    if (immediate) {\n        executeAndReschedule();\n    }\n    else {\n        lastCallTime = clock();\n        reschedule(undefined);\n    }\n    return { wake, stop };\n}\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n    if (Array.isArray(doc)) {\n        for (const document of doc) {\n            if (hasAtomicOperators(document)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    const keys = Object.keys(doc);\n    return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n    var _a, _b, _c;\n    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));\n    // Users cannot pass a readConcern/writeConcern to operations in a transaction\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n        const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n        if (readConcern) {\n            result.readConcern = readConcern;\n        }\n        const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n        if (writeConcern) {\n            result.writeConcern = writeConcern;\n        }\n    }\n    const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n    if (readPreference) {\n        result.readPreference = readPreference;\n    }\n    return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n    set = Array.isArray(set) ? new Set(set) : set;\n    subset = Array.isArray(subset) ? new Set(subset) : subset;\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\nfunction isHello(doc) {\n    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\nfunction setDifference(setA, setB) {\n    const difference = new Set(setA);\n    for (const elem of setB) {\n        difference.delete(elem);\n    }\n    return difference;\n}\nexports.setDifference = setDifference;\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\nfunction isRecord(value, requiredKeys = undefined) {\n    if (!isObject(value)) {\n        return false;\n    }\n    const ctor = value.constructor;\n    if (ctor && ctor.prototype) {\n        if (!isObject(ctor.prototype)) {\n            return false;\n        }\n        // Check to see if some method exists from the Object exists\n        if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n            return false;\n        }\n    }\n    if (requiredKeys) {\n        const keys = Object.keys(value);\n        return isSuperset(keys, requiredKeys);\n    }\n    return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n    if (value == null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        return value.map(item => deepCopy(item));\n    }\n    else if (isRecord(value)) {\n        const res = {};\n        for (const key in value) {\n            res[key] = deepCopy(value[key]);\n        }\n        return res;\n    }\n    const ctor = value.constructor;\n    if (ctor) {\n        switch (ctor.name.toLowerCase()) {\n            case 'date':\n                return new ctor(Number(value));\n            case 'map':\n                return new Map(value);\n            case 'set':\n                return new Set(value);\n            case 'buffer':\n                return Buffer.from(value);\n        }\n    }\n    return value;\n}\nexports.deepCopy = deepCopy;\n/** @internal */\nconst kBuffers = Symbol('buffers');\n/** @internal */\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nclass BufferPool {\n    constructor() {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n    }\n    get length() {\n        return this[kLength];\n    }\n    /** Adds a buffer to the internal buffer pool list */\n    append(buffer) {\n        this[kBuffers].push(buffer);\n        this[kLength] += buffer.length;\n    }\n    /** Returns the requested number of bytes without consuming them */\n    peek(size) {\n        return this.read(size, false);\n    }\n    /** Reads the requested number of bytes, optionally consuming them */\n    read(size, consume = true) {\n        if (typeof size !== 'number' || size < 0) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n        }\n        if (size > this[kLength]) {\n            return Buffer.alloc(0);\n        }\n        let result;\n        // read the whole buffer\n        if (size === this.length) {\n            result = Buffer.concat(this[kBuffers]);\n            if (consume) {\n                this[kBuffers] = [];\n                this[kLength] = 0;\n            }\n        }\n        // size is within first buffer, no need to concat\n        else if (size <= this[kBuffers][0].length) {\n            result = this[kBuffers][0].slice(0, size);\n            if (consume) {\n                this[kBuffers][0] = this[kBuffers][0].slice(size);\n                this[kLength] -= size;\n            }\n        }\n        // size is beyond first buffer, need to track and copy\n        else {\n            result = Buffer.allocUnsafe(size);\n            let idx;\n            let offset = 0;\n            let bytesToCopy = size;\n            for (idx = 0; idx < this[kBuffers].length; ++idx) {\n                let bytesCopied;\n                if (bytesToCopy > this[kBuffers][idx].length) {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n                    offset += bytesCopied;\n                }\n                else {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n                    if (consume) {\n                        this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n                    }\n                    offset += bytesCopied;\n                    break;\n                }\n                bytesToCopy -= bytesCopied;\n            }\n            // compact the internal buffer array\n            if (consume) {\n                this[kBuffers] = this[kBuffers].slice(idx);\n                this[kLength] -= size;\n            }\n        }\n        return result;\n    }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n    constructor(hostString) {\n        const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n        const { hostname, port } = new url_1.URL(`mongodb://${escapedHost}`);\n        if (hostname.endsWith('.sock')) {\n            // heuristically determine if we're working with a domain socket\n            this.socketPath = decodeURIComponent(hostname);\n        }\n        else if (typeof hostname === 'string') {\n            this.isIPv6 = false;\n            let normalized = decodeURIComponent(hostname).toLowerCase();\n            if (normalized.startsWith('[') && normalized.endsWith(']')) {\n                this.isIPv6 = true;\n                normalized = normalized.substring(1, hostname.length - 1);\n            }\n            this.host = normalized.toLowerCase();\n            if (typeof port === 'number') {\n                this.port = port;\n            }\n            else if (typeof port === 'string' && port !== '') {\n                this.port = Number.parseInt(port, 10);\n            }\n            else {\n                this.port = 27017;\n            }\n            if (this.port === 0) {\n                throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n            }\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n        }\n        Object.freeze(this);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new HostAddress('${this.toString(true)}')`;\n    }\n    /**\n     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n     */\n    toString(ipv6Brackets = false) {\n        if (typeof this.host === 'string') {\n            if (this.isIPv6 && ipv6Brackets) {\n                return `[${this.host}]:${this.port}`;\n            }\n            return `${this.host}:${this.port}`;\n        }\n        return `${this.socketPath}`;\n    }\n    static fromString(s) {\n        return new HostAddress(s);\n    }\n    static fromHostPort(host, port) {\n        if (host.includes(':')) {\n            host = `[${host}]`; // IPv6 address\n        }\n        return HostAddress.fromString(`${host}:${port}`);\n    }\n    static fromSrvRecord({ name, port }) {\n        return HostAddress.fromHostPort(name, port);\n    }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n    // We prefer not to rely on ObjectId having a createPk method\n    createPk() {\n        return new bson_1.ObjectId();\n    }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n    if (!emittedWarnings.has(message)) {\n        emittedWarnings.add(message);\n        return emitWarning(message);\n    }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n    return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n    if (!server) {\n        return false;\n    }\n    if (server.loadBalanced) {\n        // Loadbalanced topologies will always support retry writes\n        return true;\n    }\n    if (server.description.logicalSessionTimeoutMinutes != null) {\n        // that supports sessions\n        if (server.description.type !== common_1.ServerType.Standalone) {\n            // and that is not a standalone\n            return true;\n        }\n    }\n    return false;\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\nfunction parsePackageVersion({ version }) {\n    const [major, minor, patch] = version.split('.').map((n) => Number.parseInt(n, 10));\n    return { major, minor, patch };\n}\nexports.parsePackageVersion = parsePackageVersion;\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\nfunction shuffle(sequence, limit = 0) {\n    const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n    if (limit > items.length) {\n        throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n    }\n    let remainingItemsToShuffle = items.length;\n    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n    while (remainingItemsToShuffle > lowerBound) {\n        // Pick a remaining element\n        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n        remainingItemsToShuffle -= 1;\n        // And swap it with the current element\n        const swapHold = items[remainingItemsToShuffle];\n        items[remainingItemsToShuffle] = items[randomIndex];\n        items[randomIndex] = swapHold;\n    }\n    return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\nexports.shuffle = shuffle;\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n        return true;\n    }\n    if (command.mapReduce &&\n        options &&\n        options.out &&\n        (options.out.inline === 1 || options.out === 'inline')) {\n        return true;\n    }\n    return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\nfunction getMongoDBClientEncryption() {\n    let mongodbClientEncryption = null;\n    // NOTE(NODE-4254): This is to get around the circular dependency between\n    // mongodb-client-encryption and the driver in the test scenarios.\n    if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' &&\n        process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n        try {\n            // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n            // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n            // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n            mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n        }\n        catch {\n            // ignore\n        }\n    }\n    else {\n        try {\n            // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n            // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n            // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n            mongodbClientEncryption = require('mongodb-client-encryption');\n        }\n        catch {\n            // ignore\n        }\n    }\n    return mongodbClientEncryption;\n}\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}