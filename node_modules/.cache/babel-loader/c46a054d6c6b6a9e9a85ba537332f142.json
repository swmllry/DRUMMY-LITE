{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\n\nconst constants_1 = require(\"../constants\");\n\nconst utils_1 = require(\"../utils\");\n\nconst commands_1 = require(\"./commands\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   */\n  constructor(connection, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection); // TODO: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.databaseName = databaseName(command);\n    this.commandName = commandName;\n    this.command = maybeRedact(commandName, cmd, cmd);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param reply - the reply for this command from the server\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = (0, utils_1.calculateDurationInMs)(started);\n    this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param error - the generated error or a server error response\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = (0, utils_1.calculateDurationInMs)(started);\n    this.failure = maybeRedact(commandName, cmd, error);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);\nconst HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\n\nfunction extractCommand(command) {\n  var _a;\n\n  if (command instanceof commands_1.Msg) {\n    return (0, utils_1.deepCopy)(command.command);\n  }\n\n  if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // up-convert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // up-convert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (command.query[key] != null) {\n          result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);\n        }\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      const legacyKey = key;\n\n      if (command[legacyKey] != null) {\n        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);\n      }\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) {\n        result[key] = command[key];\n      }\n    });\n\n    if (command.pre32Limit != null) {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  const clonedQuery = {};\n  const clonedCommand = {};\n\n  if (command.query) {\n    for (const k in command.query) {\n      clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);\n    }\n\n    clonedCommand.query = clonedQuery;\n  }\n\n  for (const k in command) {\n    if (k === 'query') continue;\n    clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);\n  }\n\n  return command.query ? clonedQuery : clonedCommand;\n}\n\nfunction extractReply(command, reply) {\n  if (!reply) {\n    return reply;\n  }\n\n  if (command instanceof commands_1.Msg) {\n    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);\n  } // is this a legacy find command?\n\n\n  if (command.query && command.query.$query != null) {\n    return {\n      ok: 1,\n      cursor: {\n        id: (0, utils_1.deepCopy)(reply.cursorId),\n        ns: namespace(command),\n        firstBatch: (0, utils_1.deepCopy)(reply.documents)\n      }\n    };\n  }\n\n  return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);\n}\n\nfunction extractConnectionDetails(connection) {\n  let connectionId;\n\n  if ('id' in connection) {\n    connectionId = connection.id;\n  }\n\n  return {\n    address: connection.address,\n    serviceId: connection.serviceId,\n    connectionId\n  };\n}","map":{"version":3,"sources":["../../src/cmap/command_monitoring_events.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\nconst constants_1 = require(\"../constants\");\nconst utils_1 = require(\"../utils\");\nconst commands_1 = require(\"./commands\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\nclass CommandStartedEvent {\n    /**\n     * Create a started event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     */\n    constructor(connection, command) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        // TODO: remove in major revision, this is not spec behavior\n        if (SENSITIVE_COMMANDS.has(commandName)) {\n            this.commandObj = {};\n            this.commandObj[commandName] = true;\n        }\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.databaseName = databaseName(command);\n        this.commandName = commandName;\n        this.command = maybeRedact(commandName, cmd, cmd);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\nclass CommandSucceededEvent {\n    /**\n     * Create a succeeded event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param reply - the reply for this command from the server\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, reply, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = (0, utils_1.calculateDurationInMs)(started);\n        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\nclass CommandFailedEvent {\n    /**\n     * Create a failure event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param error - the generated error or a server error response\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, error, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = (0, utils_1.calculateDurationInMs)(started);\n        this.failure = maybeRedact(commandName, cmd, error);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n    'authenticate',\n    'saslStart',\n    'saslContinue',\n    'getnonce',\n    'createUser',\n    'updateUser',\n    'copydbgetnonce',\n    'copydbsaslstart',\n    'copydb'\n]);\nconst HELLO_COMMANDS = new Set(['hello', constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);\n// helper methods\nconst extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];\nconst namespace = (command) => command.ns;\nconst databaseName = (command) => command.ns.split('.')[0];\nconst collectionName = (command) => command.ns.split('.')[1];\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) ||\n    (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)\n    ? {}\n    : result;\nconst LEGACY_FIND_QUERY_MAP = {\n    $query: 'filter',\n    $orderby: 'sort',\n    $hint: 'hint',\n    $comment: 'comment',\n    $maxScan: 'maxScan',\n    $max: 'max',\n    $min: 'min',\n    $returnKey: 'returnKey',\n    $showDiskLoc: 'showRecordId',\n    $maxTimeMS: 'maxTimeMS',\n    $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n    numberToSkip: 'skip',\n    numberToReturn: 'batchSize',\n    returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'partial',\n    'exhaust'\n];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\nfunction extractCommand(command) {\n    var _a;\n    if (command instanceof commands_1.Msg) {\n        return (0, utils_1.deepCopy)(command.command);\n    }\n    if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n        let result;\n        if (command.ns === 'admin.$cmd') {\n            // up-convert legacy command\n            result = Object.assign({}, command.query.$query);\n        }\n        else {\n            // up-convert legacy find command\n            result = { find: collectionName(command) };\n            Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n                if (command.query[key] != null) {\n                    result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);\n                }\n            });\n        }\n        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n            const legacyKey = key;\n            if (command[legacyKey] != null) {\n                result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);\n            }\n        });\n        OP_QUERY_KEYS.forEach(key => {\n            if (command[key]) {\n                result[key] = command[key];\n            }\n        });\n        if (command.pre32Limit != null) {\n            result.limit = command.pre32Limit;\n        }\n        if (command.query.$explain) {\n            return { explain: result };\n        }\n        return result;\n    }\n    const clonedQuery = {};\n    const clonedCommand = {};\n    if (command.query) {\n        for (const k in command.query) {\n            clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);\n        }\n        clonedCommand.query = clonedQuery;\n    }\n    for (const k in command) {\n        if (k === 'query')\n            continue;\n        clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);\n    }\n    return command.query ? clonedQuery : clonedCommand;\n}\nfunction extractReply(command, reply) {\n    if (!reply) {\n        return reply;\n    }\n    if (command instanceof commands_1.Msg) {\n        return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);\n    }\n    // is this a legacy find command?\n    if (command.query && command.query.$query != null) {\n        return {\n            ok: 1,\n            cursor: {\n                id: (0, utils_1.deepCopy)(reply.cursorId),\n                ns: namespace(command),\n                firstBatch: (0, utils_1.deepCopy)(reply.documents)\n            }\n        };\n    }\n    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);\n}\nfunction extractConnectionDetails(connection) {\n    let connectionId;\n    if ('id' in connection) {\n        connectionId = connection.id;\n    }\n    return {\n        address: connection.address,\n        serviceId: connection.serviceId,\n        connectionId\n    };\n}\n//# sourceMappingURL=command_monitoring_events.js.map"]},"metadata":{},"sourceType":"script"}