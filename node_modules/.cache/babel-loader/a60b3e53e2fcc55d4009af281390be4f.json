{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst download_1 = require(\"./download\");\n\nconst upload_1 = require(\"./upload\");\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\n\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = { ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n\n\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, { ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n\n\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n\n  delete(id, callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      return this.s._filesCollection.deleteOne({\n        _id: id\n      }, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n\n        return this.s._chunksCollection.deleteMany({\n          files_id: id\n        }, error => {\n          if (error) {\n            return callback(error);\n          } // Delete orphaned chunks before returning FileNotFound\n\n\n          if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {\n            // TODO(NODE-3483): Replace with more appropriate error\n            // Consider creating new error MongoGridFSFileNotFoundError\n            return callback(new error_1.MongoRuntimeError(`File not found for id ${id}`));\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n  /** Convenience wrapper around find on the files collection */\n\n\n  find(filter, options) {\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n\n\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, { ...options,\n      sort,\n      skip\n    });\n  }\n\n  rename(id, filename, callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      const filter = {\n        _id: id\n      };\n      const update = {\n        $set: {\n          filename\n        }\n      };\n      return this.s._filesCollection.updateOne(filter, update, (error, res) => {\n        if (error) {\n          return callback(error);\n        }\n\n        if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {\n          return callback(new error_1.MongoRuntimeError(`File with id ${id} not found`));\n        }\n\n        return callback();\n      });\n    });\n  }\n\n  drop(callback) {\n    return (0, utils_1.maybePromise)(callback, callback => {\n      return this.s._filesCollection.drop(error => {\n        if (error) {\n          return callback(error);\n        }\n\n        return this.s._chunksCollection.drop(error => {\n          if (error) {\n            return callback(error);\n          }\n\n          return callback();\n        });\n      });\n    });\n  }\n  /** Get the Db scoped logger. */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n}\n\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\n\nGridFSBucket.INDEX = 'index';","map":{"version":3,"sources":["../../src/gridfs/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n    bucketName: 'fs',\n    chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n    constructor(db, options) {\n        super();\n        this.setMaxListeners(0);\n        const privateOptions = {\n            ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n            ...options,\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n        };\n        this.s = {\n            db,\n            options: privateOptions,\n            _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n            _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n            checkedIndexes: false,\n            calledOpenUploadStream: false\n        };\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS. The stream's 'id' property contains the resulting\n     * file's id.\n     *\n     * @param filename - The value of the 'filename' key in the files doc\n     * @param options - Optional settings.\n     */\n    openUploadStream(filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, options);\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n     * file's id.\n     */\n    openUploadStreamWithId(id, filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });\n    }\n    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n    openDownloadStream(id, options) {\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);\n    }\n    delete(id, callback) {\n        return (0, utils_1.maybePromise)(callback, callback => {\n            return this.s._filesCollection.deleteOne({ _id: id }, (error, res) => {\n                if (error) {\n                    return callback(error);\n                }\n                return this.s._chunksCollection.deleteMany({ files_id: id }, error => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    // Delete orphaned chunks before returning FileNotFound\n                    if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {\n                        // TODO(NODE-3483): Replace with more appropriate error\n                        // Consider creating new error MongoGridFSFileNotFoundError\n                        return callback(new error_1.MongoRuntimeError(`File not found for id ${id}`));\n                    }\n                    return callback();\n                });\n            });\n        });\n    }\n    /** Convenience wrapper around find on the files collection */\n    find(filter, options) {\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.s._filesCollection.find(filter, options);\n    }\n    /**\n     * Returns a readable stream (GridFSBucketReadStream) for streaming the\n     * file with the given name from GridFS. If there are multiple files with\n     * the same name, this will stream the most recent file with the given name\n     * (as determined by the `uploadDate` field). You can set the `revision`\n     * option to change this behavior.\n     */\n    openDownloadStreamByName(filename, options) {\n        let sort = { uploadDate: -1 };\n        let skip = undefined;\n        if (options && options.revision != null) {\n            if (options.revision >= 0) {\n                sort = { uploadDate: 1 };\n                skip = options.revision;\n            }\n            else {\n                skip = -options.revision - 1;\n            }\n        }\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });\n    }\n    rename(id, filename, callback) {\n        return (0, utils_1.maybePromise)(callback, callback => {\n            const filter = { _id: id };\n            const update = { $set: { filename } };\n            return this.s._filesCollection.updateOne(filter, update, (error, res) => {\n                if (error) {\n                    return callback(error);\n                }\n                if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {\n                    return callback(new error_1.MongoRuntimeError(`File with id ${id} not found`));\n                }\n                return callback();\n            });\n        });\n    }\n    drop(callback) {\n        return (0, utils_1.maybePromise)(callback, callback => {\n            return this.s._filesCollection.drop(error => {\n                if (error) {\n                    return callback(error);\n                }\n                return this.s._chunksCollection.drop(error => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    return callback();\n                });\n            });\n        });\n    }\n    /** Get the Db scoped logger. */\n    getLogger() {\n        return this.s.db.s.logger;\n    }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\nGridFSBucket.INDEX = 'index';\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}