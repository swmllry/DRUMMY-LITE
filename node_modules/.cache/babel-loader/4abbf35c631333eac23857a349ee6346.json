{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst connection_string_1 = require(\"./connection_string\");\n\nconst db_1 = require(\"./db\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst connect_1 = require(\"./operations/connect\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst sessions_1 = require(\"./sessions\");\n\nconst utils_1 = require(\"./utils\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const client = this; // The internal state\n\n    this.s = {\n      url,\n      bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n      hasBeenClosed: false,\n      sessionPool: new sessions_1.ServerSessionPool(this),\n      activeSessions: new Set(),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get logger() {\n        return client[kOptions].logger;\n      },\n\n      get isMongoClient() {\n        return true;\n      }\n\n    };\n  }\n\n  get options() {\n    return Object.freeze({ ...this[kOptions]\n    });\n  }\n\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n\n\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get readPreference() {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n\n  get logger() {\n    return this.s.logger;\n  }\n\n  connect(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n\n    return (0, utils_1.maybePromise)(callback, cb => {\n      (0, connect_1.connect)(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n\n  close(forceOrCallback, callback) {\n    // There's no way to set hasBeenClosed back to false\n    Object.defineProperty(this.s, 'hasBeenClosed', {\n      value: true,\n      enumerable: true,\n      configurable: false,\n      writable: false\n    });\n\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return (0, utils_1.maybePromise)(callback, callback => {\n      if (this.topology == null) {\n        // Do not connect just to end sessions\n        return callback();\n      }\n\n      const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());\n      this.s.activeSessions.clear();\n      Promise.all(activeSessionEnds).then(() => {\n        const endSessions = Array.from(this.s.sessionPool.sessions, _ref => {\n          let {\n            id\n          } = _ref;\n          return id;\n        });\n        if (endSessions.length === 0) return;\n        return this.db('admin').command({\n          endSessions\n        }, {\n          readPreference: read_preference_1.ReadPreference.primaryPreferred,\n          noResponse: true\n        }).catch(() => null); // outcome does not matter\n      }).then(() => {\n        if (this.topology == null) {\n          return callback();\n        } // clear out references to old topology\n\n\n        const topology = this.topology;\n        this.topology = undefined;\n        return new Promise((resolve, reject) => {\n          topology.close({\n            force\n          }, error => {\n            if (error) return reject(error);\n            const {\n              encrypter\n            } = this[kOptions];\n\n            if (encrypter) {\n              return encrypter.close(this, force, error => {\n                if (error) return reject(error);\n                resolve();\n              });\n            }\n\n            resolve();\n          });\n        });\n      }).then(() => callback(), error => callback(error));\n    });\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n\n\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided\n\n    if (!dbName) {\n      dbName = this.options.dbName;\n    } // Copy the options and add out internal override of the not shared flag\n\n\n    const finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n    const db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n    return db;\n  }\n\n  static connect(url, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options); // Execute the connect method\n\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n    }\n  }\n\n  startSession(options) {\n    const session = new sessions_1.ClientSession(this, this.s.sessionPool, {\n      explicit: true,\n      ...options\n    }, this[kOptions]);\n    this.s.activeSessions.add(session);\n    session.once('ended', () => {\n      this.s.activeSessions.delete(session);\n    });\n    return session;\n  }\n\n  withSession(optionsOrOperation, callback) {\n    const options = {\n      // Always define an owner\n      owner: Symbol(),\n      // If it's an object inherit the options\n      ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})\n    };\n    const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n\n    if (withSessionCallback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n\n    const session = this.startSession(options);\n    const Promise = promise_provider_1.PromiseProvider.get();\n    return Promise.resolve().then(() => withSessionCallback(session)).then(() => {// Do not return the result of callback\n    }).finally(() => {\n      session.endSession().catch(() => null);\n    });\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct usecases:\n   * - The first is to provide the schema that may be defined for all the data within the current cluster\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TSchema - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n\n\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Return the mongo client logger */\n\n\n  getLogger() {\n    return this.s.logger;\n  }\n\n}\n\nexports.MongoClient = MongoClient;","map":{"version":3,"sources":["../src/mongo_client.ts"],"names":[],"mappings":";;;;;;;AAGA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAMA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,MAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAGA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAIA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAWA;;;AACa,OAAA,CAAA,gBAAA,GAAmB,MAAM,CAAC,MAAP,CAAc;EAC5C,EAAE,EAAE;AADwC,CAAd,CAAnB;AAgQb;;AACA,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAD,CAAvB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCG;;AACH,MAAa,WAAb,SAAiC,aAAA,CAAA,iBAAjC,CAAqE;EAYnE,WAAA,CAAY,GAAZ,EAAyB,OAAzB,EAAqD;IACnD;IAEA,KAAK,QAAL,IAAiB,CAAA,GAAA,mBAAA,CAAA,YAAA,EAAa,GAAb,EAAkB,IAAlB,EAAwB,OAAxB,CAAjB,CAHmD,CAKnD;;IACA,MAAM,MAAM,GAAG,IAAf,CANmD,CAQnD;;IACA,KAAK,CAAL,GAAS;MACP,GADO;MAEP,WAAW,EAAE,CAAA,GAAA,MAAA,CAAA,kBAAA,EAAmB,KAAK,QAAL,CAAnB,CAFN;MAGP,SAAS,EAAE,CAAA,GAAA,OAAA,CAAA,EAAA,EAAG,OAAH,CAHJ;MAIP,aAAa,EAAE,KAJR;MAKP,WAAW,EAAE,IAAI,UAAA,CAAA,iBAAJ,CAAsB,IAAtB,CALN;MAMP,cAAc,EAAE,IAAI,GAAJ,EANT;;MAQP,IAAI,OAAJ,GAAW;QACT,OAAO,MAAM,CAAC,QAAD,CAAb;MACD,CAVM;;MAWP,IAAI,WAAJ,GAAe;QACb,OAAO,MAAM,CAAC,QAAD,CAAN,CAAiB,WAAxB;MACD,CAbM;;MAcP,IAAI,YAAJ,GAAgB;QACd,OAAO,MAAM,CAAC,QAAD,CAAN,CAAiB,YAAxB;MACD,CAhBM;;MAiBP,IAAI,cAAJ,GAAkB;QAChB,OAAO,MAAM,CAAC,QAAD,CAAN,CAAiB,cAAxB;MACD,CAnBM;;MAoBP,IAAI,MAAJ,GAAU;QACR,OAAO,MAAM,CAAC,QAAD,CAAN,CAAiB,MAAxB;MACD,CAtBM;;MAuBP,IAAI,aAAJ,GAAiB;QACf,OAAO,IAAP;MACD;;IAzBM,CAAT;EA2BD;;EAEU,IAAP,OAAO,GAAA;IACT,OAAO,MAAM,CAAC,MAAP,CAAc,EAAE,GAAG,KAAK,QAAL;IAAL,CAAd,CAAP;EACD;;EAEY,IAAT,SAAS,GAAA;IACX,OAAO,KAAK,QAAL,EAAe,SAAf,IAA4B,MAAM,CAAC,MAAP,CAAc,EAAE,GAAG,KAAK,QAAL,EAAe;IAApB,CAAd,CAAnC;EACD;EACD;;;AAGG;;;EACgB,IAAf,eAAe,GAAA;IACjB,OAAO,KAAK,QAAL,EAAe,eAAtB;EACD;;EACkB,IAAf,eAAe,CAAC,KAAD,EAAe;IAChC,KAAK,QAAL,EAAe,eAAf,GAAiC,KAAjC;EACD;;EAEgB,IAAb,aAAa,GAAA;IACf,OAAO,KAAK,QAAL,EAAe,aAAtB;EACD;;EAEc,IAAX,WAAW,GAAA;IACb,OAAO,KAAK,CAAL,CAAO,WAAd;EACD;;EAEe,IAAZ,YAAY,GAAA;IACd,OAAO,KAAK,CAAL,CAAO,YAAd;EACD;;EAEiB,IAAd,cAAc,GAAA;IAChB,OAAO,KAAK,CAAL,CAAO,cAAd;EACD;;EAEc,IAAX,WAAW,GAAA;IACb,OAAO,KAAK,CAAL,CAAO,WAAd;EACD;;EAES,IAAN,MAAM,GAAA;IACR,OAAO,KAAK,CAAL,CAAO,MAAd;EACD;;EASD,OAAO,CAAC,QAAD,EAA0B;IAC/B,IAAI,QAAQ,IAAI,OAAO,QAAP,KAAoB,UAApC,EAAgD;MAC9C,MAAM,IAAI,OAAA,CAAA,yBAAJ,CAA8B,0CAA9B,CAAN;IACD;;IAED,OAAO,CAAA,GAAA,OAAA,CAAA,YAAA,EAAa,QAAb,EAAuB,EAAE,IAAG;MACjC,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,IAAR,EAAc,KAAK,QAAL,CAAd,EAA8B,GAAG,IAAG;QAClC,IAAI,GAAJ,EAAS,OAAO,EAAE,CAAC,GAAD,CAAT;QACT,EAAE,CAAC,SAAD,EAAY,IAAZ,CAAF;MACD,CAHD;IAID,CALM,CAAP;EAMD;;EAYD,KAAK,CACH,eADG,EAEH,QAFG,EAEsB;IAEzB;IACA,MAAM,CAAC,cAAP,CAAsB,KAAK,CAA3B,EAA8B,eAA9B,EAA+C;MAC7C,KAAK,EAAE,IADsC;MAE7C,UAAU,EAAE,IAFiC;MAG7C,YAAY,EAAE,KAH+B;MAI7C,QAAQ,EAAE;IAJmC,CAA/C;;IAOA,IAAI,OAAO,eAAP,KAA2B,UAA/B,EAA2C;MACzC,QAAQ,GAAG,eAAX;IACD;;IAED,MAAM,KAAK,GAAG,OAAO,eAAP,KAA2B,SAA3B,GAAuC,eAAvC,GAAyD,KAAvE;IAEA,OAAO,CAAA,GAAA,OAAA,CAAA,YAAA,EAAa,QAAb,EAAuB,QAAQ,IAAG;MACvC,IAAI,KAAK,QAAL,IAAiB,IAArB,EAA2B;QACzB;QACA,OAAO,QAAQ,EAAf;MACD;;MAED,MAAM,iBAAiB,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,CAAL,CAAO,cAAlB,EAAkC,OAAO,IAAI,OAAO,CAAC,UAAR,EAA7C,CAA1B;MACA,KAAK,CAAL,CAAO,cAAP,CAAsB,KAAtB;MAEA,OAAO,CAAC,GAAR,CAAY,iBAAZ,EACG,IADH,CACQ,MAAK;QACT,MAAM,WAAW,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,CAAL,CAAO,WAAP,CAAmB,QAA9B,EAAwC;UAAA,IAAC;YAAE;UAAF,CAAD;UAAA,OAAY,EAAZ;QAAA,CAAxC,CAApB;QACA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;QAC9B,OAAO,KAAK,EAAL,CAAQ,OAAR,EACJ,OADI,CAEH;UAAE;QAAF,CAFG,EAGH;UAAE,cAAc,EAAE,iBAAA,CAAA,cAAA,CAAe,gBAAjC;UAAmD,UAAU,EAAE;QAA/D,CAHG,EAKJ,KALI,CAKE,MAAM,IALR,CAAP,CAHS,CAQa;MACvB,CAVH,EAWG,IAXH,CAWQ,MAAK;QACT,IAAI,KAAK,QAAL,IAAiB,IAArB,EAA2B;UACzB,OAAO,QAAQ,EAAf;QACD,CAHQ,CAIT;;;QACA,MAAM,QAAQ,GAAG,KAAK,QAAtB;QACA,KAAK,QAAL,GAAgB,SAAhB;QAEA,OAAO,IAAI,OAAJ,CAAkB,CAAC,OAAD,EAAU,MAAV,KAAoB;UAC3C,QAAQ,CAAC,KAAT,CAAe;YAAE;UAAF,CAAf,EAA0B,KAAK,IAAG;YAChC,IAAI,KAAJ,EAAW,OAAO,MAAM,CAAC,KAAD,CAAb;YACX,MAAM;cAAE;YAAF,IAAgB,KAAK,QAAL,CAAtB;;YACA,IAAI,SAAJ,EAAe;cACb,OAAO,SAAS,CAAC,KAAV,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,KAAK,IAAG;gBAC1C,IAAI,KAAJ,EAAW,OAAO,MAAM,CAAC,KAAD,CAAb;gBACX,OAAO;cACR,CAHM,CAAP;YAID;;YACD,OAAO;UACR,CAVD;QAWD,CAZM,CAAP;MAaD,CAhCH,EAiCG,IAjCH,CAkCI,MAAM,QAAQ,EAlClB,EAmCI,KAAK,IAAI,QAAQ,CAAC,KAAD,CAnCrB;IAqCD,CA9CM,CAAP;EA+CD;EAED;;;;;AAKG;;;EACH,EAAE,CAAC,MAAD,EAAkB,OAAlB,EAAqC;IACrC,OAAO,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,EAArB,CADqC,CAGrC;;IACA,IAAI,CAAC,MAAL,EAAa;MACX,MAAM,GAAG,KAAK,OAAL,CAAa,MAAtB;IACD,CANoC,CAQrC;;;IACA,MAAM,YAAY,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,QAAL,CAAlB,EAAkC,OAAlC,CAArB,CATqC,CAWrC;;IACA,MAAM,EAAE,GAAG,IAAI,IAAA,CAAA,EAAJ,CAAO,IAAP,EAAa,MAAb,EAAqB,YAArB,CAAX,CAZqC,CAcrC;;IACA,OAAO,EAAP;EACD;;EAca,OAAP,OAAO,CACZ,GADY,EAEZ,OAFY,EAGZ,QAHY,EAGoB;IAEhC,IAAI,OAAO,OAAP,KAAmB,UAAvB,EAAoC,QAAQ,GAAG,OAAZ,EAAuB,OAAO,GAAG,EAAjC;IACnC,OAAO,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,EAArB;;IAEA,IAAI;MACF;MACA,MAAM,WAAW,GAAG,IAAI,WAAJ,CAAgB,GAAhB,EAAqB,OAArB,CAApB,CAFE,CAGF;;MACA,IAAI,QAAJ,EAAc;QACZ,OAAO,WAAW,CAAC,OAAZ,CAAoB,QAApB,CAAP;MACD,CAFD,MAEO;QACL,OAAO,WAAW,CAAC,OAAZ,EAAP;MACD;IACF,CATD,CASE,OAAO,KAAP,EAAc;MACd,IAAI,QAAJ,EAAc,OAAO,QAAQ,CAAC,KAAD,CAAf,CAAd,KACK,OAAO,kBAAA,CAAA,eAAA,CAAgB,GAAhB,GAAsB,MAAtB,CAA6B,KAA7B,CAAP;IACN;EACF;;EAKD,YAAY,CAAC,OAAD,EAA+B;IACzC,MAAM,OAAO,GAAG,IAAI,UAAA,CAAA,aAAJ,CACd,IADc,EAEd,KAAK,CAAL,CAAO,WAFO,EAGd;MAAE,QAAQ,EAAE,IAAZ;MAAkB,GAAG;IAArB,CAHc,EAId,KAAK,QAAL,CAJc,CAAhB;IAMA,KAAK,CAAL,CAAO,cAAP,CAAsB,GAAtB,CAA0B,OAA1B;IACA,OAAO,CAAC,IAAR,CAAa,OAAb,EAAsB,MAAK;MACzB,KAAK,CAAL,CAAO,cAAP,CAAsB,MAAtB,CAA6B,OAA7B;IACD,CAFD;IAGA,OAAO,OAAP;EACD;;EAaD,WAAW,CACT,kBADS,EAET,QAFS,EAEqB;IAE9B,MAAM,OAAO,GAAG;MACd;MACA,KAAK,EAAE,MAAM,EAFC;MAGd;MACA,IAAI,OAAO,kBAAP,KAA8B,QAA9B,GAAyC,kBAAzC,GAA8D,EAAlE;IAJc,CAAhB;IAOA,MAAM,mBAAmB,GACvB,OAAO,kBAAP,KAA8B,UAA9B,GAA2C,kBAA3C,GAAgE,QADlE;;IAGA,IAAI,mBAAmB,IAAI,IAA3B,EAAiC;MAC/B,MAAM,IAAI,OAAA,CAAA,yBAAJ,CAA8B,qCAA9B,CAAN;IACD;;IAED,MAAM,OAAO,GAAG,KAAK,YAAL,CAAkB,OAAlB,CAAhB;IACA,MAAM,OAAO,GAAG,kBAAA,CAAA,eAAA,CAAgB,GAAhB,EAAhB;IAEA,OAAO,OAAO,CAAC,OAAR,GACJ,IADI,CACC,MAAM,mBAAmB,CAAC,OAAD,CAD1B,EAEJ,IAFI,CAEC,MAAK,CACT;IACD,CAJI,EAKJ,OALI,CAKI,MAAK;MACZ,OAAO,CAAC,UAAR,GAAqB,KAArB,CAA2B,MAAM,IAAjC;IACD,CAPI,CAAP;EAQD;EAED;;;;;;;;;;;;;;AAcG;;;EACH,KAAK,GAGyD;IAAA,IAA5D,QAA4D,uEAArC,EAAqC;IAAA,IAAjC,OAAiC,uEAAF,EAAE;;IAC5D;IACA,IAAI,CAAC,KAAK,CAAC,OAAN,CAAc,QAAd,CAAL,EAA8B;MAC5B,OAAO,GAAG,QAAV;MACA,QAAQ,GAAG,EAAX;IACD;;IAED,OAAO,IAAI,eAAA,CAAA,YAAJ,CAAmC,IAAnC,EAAyC,QAAzC,EAAmD,CAAA,GAAA,OAAA,CAAA,cAAA,EAAe,IAAf,EAAqB,OAArB,CAAnD,CAAP;EACD;EAED;;;EACA,SAAS,GAAA;IACP,OAAO,KAAK,CAAL,CAAO,MAAd;EACD;;AAlVkE;;AAArE,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst bson_1 = require(\"./bson\");\nconst change_stream_1 = require(\"./change_stream\");\nconst connection_string_1 = require(\"./connection_string\");\nconst db_1 = require(\"./db\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst connect_1 = require(\"./operations/connect\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst read_preference_1 = require(\"./read_preference\");\nconst sessions_1 = require(\"./sessions\");\nconst utils_1 = require(\"./utils\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n    v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n    constructor(url, options) {\n        super();\n        this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const client = this;\n        // The internal state\n        this.s = {\n            url,\n            bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n            namespace: (0, utils_1.ns)('admin'),\n            hasBeenClosed: false,\n            sessionPool: new sessions_1.ServerSessionPool(this),\n            activeSessions: new Set(),\n            get options() {\n                return client[kOptions];\n            },\n            get readConcern() {\n                return client[kOptions].readConcern;\n            },\n            get writeConcern() {\n                return client[kOptions].writeConcern;\n            },\n            get readPreference() {\n                return client[kOptions].readPreference;\n            },\n            get logger() {\n                return client[kOptions].logger;\n            },\n            get isMongoClient() {\n                return true;\n            }\n        };\n    }\n    get options() {\n        return Object.freeze({ ...this[kOptions] });\n    }\n    get serverApi() {\n        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n    get monitorCommands() {\n        return this[kOptions].monitorCommands;\n    }\n    set monitorCommands(value) {\n        this[kOptions].monitorCommands = value;\n    }\n    get autoEncrypter() {\n        return this[kOptions].autoEncrypter;\n    }\n    get readConcern() {\n        return this.s.readConcern;\n    }\n    get writeConcern() {\n        return this.s.writeConcern;\n    }\n    get readPreference() {\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    get logger() {\n        return this.s.logger;\n    }\n    connect(callback) {\n        if (callback && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n        }\n        return (0, utils_1.maybePromise)(callback, cb => {\n            (0, connect_1.connect)(this, this[kOptions], err => {\n                if (err)\n                    return cb(err);\n                cb(undefined, this);\n            });\n        });\n    }\n    close(forceOrCallback, callback) {\n        // There's no way to set hasBeenClosed back to false\n        Object.defineProperty(this.s, 'hasBeenClosed', {\n            value: true,\n            enumerable: true,\n            configurable: false,\n            writable: false\n        });\n        if (typeof forceOrCallback === 'function') {\n            callback = forceOrCallback;\n        }\n        const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n        return (0, utils_1.maybePromise)(callback, callback => {\n            if (this.topology == null) {\n                // Do not connect just to end sessions\n                return callback();\n            }\n            const activeSessionEnds = Array.from(this.s.activeSessions, session => session.endSession());\n            this.s.activeSessions.clear();\n            Promise.all(activeSessionEnds)\n                .then(() => {\n                const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);\n                if (endSessions.length === 0)\n                    return;\n                return this.db('admin')\n                    .command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true })\n                    .catch(() => null); // outcome does not matter\n            })\n                .then(() => {\n                if (this.topology == null) {\n                    return callback();\n                }\n                // clear out references to old topology\n                const topology = this.topology;\n                this.topology = undefined;\n                return new Promise((resolve, reject) => {\n                    topology.close({ force }, error => {\n                        if (error)\n                            return reject(error);\n                        const { encrypter } = this[kOptions];\n                        if (encrypter) {\n                            return encrypter.close(this, force, error => {\n                                if (error)\n                                    return reject(error);\n                                resolve();\n                            });\n                        }\n                        resolve();\n                    });\n                });\n            })\n                .then(() => callback(), error => callback(error));\n        });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n    db(dbName, options) {\n        options = options !== null && options !== void 0 ? options : {};\n        // Default to db from connection string if not provided\n        if (!dbName) {\n            dbName = this.options.dbName;\n        }\n        // Copy the options and add out internal override of the not shared flag\n        const finalOptions = Object.assign({}, this[kOptions], options);\n        // Return the db object\n        const db = new db_1.Db(this, dbName, finalOptions);\n        // Return the database\n        return db;\n    }\n    static connect(url, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        try {\n            // Create client\n            const mongoClient = new MongoClient(url, options);\n            // Execute the connect method\n            if (callback) {\n                return mongoClient.connect(callback);\n            }\n            else {\n                return mongoClient.connect();\n            }\n        }\n        catch (error) {\n            if (callback)\n                return callback(error);\n            else\n                return promise_provider_1.PromiseProvider.get().reject(error);\n        }\n    }\n    startSession(options) {\n        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);\n        this.s.activeSessions.add(session);\n        session.once('ended', () => {\n            this.s.activeSessions.delete(session);\n        });\n        return session;\n    }\n    withSession(optionsOrOperation, callback) {\n        const options = {\n            // Always define an owner\n            owner: Symbol(),\n            // If it's an object inherit the options\n            ...(typeof optionsOrOperation === 'object' ? optionsOrOperation : {})\n        };\n        const withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n        if (withSessionCallback == null) {\n            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n        }\n        const session = this.startSession(options);\n        const Promise = promise_provider_1.PromiseProvider.get();\n        return Promise.resolve()\n            .then(() => withSessionCallback(session))\n            .then(() => {\n            // Do not return the result of callback\n        })\n            .finally(() => {\n            session.endSession().catch(() => null);\n        });\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct usecases:\n     * - The first is to provide the schema that may be defined for all the data within the current cluster\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TSchema - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /** Return the mongo client logger */\n    getLogger() {\n        return this.s.logger;\n    }\n}\nexports.MongoClient = MongoClient;\n//# sourceMappingURL=mongo_client.js.map"]},"metadata":{},"sourceType":"script"}