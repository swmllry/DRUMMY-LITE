{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreateCollectionOperation = void 0;\n\nconst collection_1 = require(\"../collection\");\n\nconst command_1 = require(\"./command\");\n\nconst indexes_1 = require(\"./indexes\");\n\nconst operation_1 = require(\"./operation\");\n\nconst ILLEGAL_COMMAND_FIELDS = new Set(['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'pkFactory', 'raw', 'readPreference', 'session', 'readConcern', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation']);\n/** @internal */\n\nclass CreateCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.options = options;\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d, _e, _f;\n\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n      const encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c[`${db.databaseName}.${name}`];\n\n      if (encryptedFields) {\n        // Create auxilliary collections for queryable encryption support.\n        const escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : `enxcol_.${name}.esc`;\n        const eccCollection = (_e = encryptedFields.eccCollection) !== null && _e !== void 0 ? _e : `enxcol_.${name}.ecc`;\n        const ecocCollection = (_f = encryptedFields.ecocCollection) !== null && _f !== void 0 ? _f : `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          const createOp = new CreateCollectionOperation(db, collectionName, {\n            clusteredIndex: {\n              key: {\n                _id: 1\n              },\n              unique: true\n            }\n          });\n          await createOp.executeWithoutEncryptedFieldsCheck(server, session);\n        }\n\n        if (!options.encryptedFields) {\n          this.options = { ...this.options,\n            encryptedFields\n          };\n        }\n      }\n\n      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);\n\n      if (encryptedFields) {\n        // Create the required index for queryable encryption support.\n        const createIndexOp = new indexes_1.CreateIndexOperation(db, name, {\n          __safeContent__: 1\n        }, {});\n        await new Promise((resolve, reject) => {\n          createIndexOp.execute(server, session, err => err ? reject(err) : resolve());\n        });\n      }\n\n      return coll;\n    })().then(coll => callback(undefined, coll), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      const db = this.db;\n      const name = this.name;\n      const options = this.options;\n\n      const done = err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(new collection_1.Collection(db, name, options));\n      };\n\n      const cmd = {\n        create: name\n      };\n\n      for (const n in options) {\n        if (options[n] != null && typeof options[n] !== 'function' && !ILLEGAL_COMMAND_FIELDS.has(n)) {\n          cmd[n] = options[n];\n        }\n      } // otherwise just execute the command\n\n\n      super.executeCommand(server, session, cmd, done);\n    });\n  }\n\n}\n\nexports.CreateCollectionOperation = CreateCollectionOperation;\n(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["../../src/operations/create_collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CreateCollectionOperation = void 0;\nconst collection_1 = require(\"../collection\");\nconst command_1 = require(\"./command\");\nconst indexes_1 = require(\"./indexes\");\nconst operation_1 = require(\"./operation\");\nconst ILLEGAL_COMMAND_FIELDS = new Set([\n    'w',\n    'wtimeout',\n    'j',\n    'fsync',\n    'autoIndexId',\n    'pkFactory',\n    'raw',\n    'readPreference',\n    'session',\n    'readConcern',\n    'writeConcern',\n    'raw',\n    'fieldsAsRaw',\n    'promoteLongs',\n    'promoteValues',\n    'promoteBuffers',\n    'bsonRegExp',\n    'serializeFunctions',\n    'ignoreUndefined',\n    'enableUtf8Validation'\n]);\n/** @internal */\nclass CreateCollectionOperation extends command_1.CommandOperation {\n    constructor(db, name, options = {}) {\n        super(db, options);\n        this.options = options;\n        this.db = db;\n        this.name = name;\n    }\n    execute(server, session, callback) {\n        (async () => {\n            var _a, _b, _c, _d, _e, _f;\n            const db = this.db;\n            const name = this.name;\n            const options = this.options;\n            const encryptedFields = (_a = options.encryptedFields) !== null && _a !== void 0 ? _a : (_c = (_b = db.s.client.options.autoEncryption) === null || _b === void 0 ? void 0 : _b.encryptedFieldsMap) === null || _c === void 0 ? void 0 : _c[`${db.databaseName}.${name}`];\n            if (encryptedFields) {\n                // Create auxilliary collections for queryable encryption support.\n                const escCollection = (_d = encryptedFields.escCollection) !== null && _d !== void 0 ? _d : `enxcol_.${name}.esc`;\n                const eccCollection = (_e = encryptedFields.eccCollection) !== null && _e !== void 0 ? _e : `enxcol_.${name}.ecc`;\n                const ecocCollection = (_f = encryptedFields.ecocCollection) !== null && _f !== void 0 ? _f : `enxcol_.${name}.ecoc`;\n                for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n                    const createOp = new CreateCollectionOperation(db, collectionName, {\n                        clusteredIndex: {\n                            key: { _id: 1 },\n                            unique: true\n                        }\n                    });\n                    await createOp.executeWithoutEncryptedFieldsCheck(server, session);\n                }\n                if (!options.encryptedFields) {\n                    this.options = { ...this.options, encryptedFields };\n                }\n            }\n            const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);\n            if (encryptedFields) {\n                // Create the required index for queryable encryption support.\n                const createIndexOp = new indexes_1.CreateIndexOperation(db, name, { __safeContent__: 1 }, {});\n                await new Promise((resolve, reject) => {\n                    createIndexOp.execute(server, session, err => (err ? reject(err) : resolve()));\n                });\n            }\n            return coll;\n        })().then(coll => callback(undefined, coll), err => callback(err));\n    }\n    executeWithoutEncryptedFieldsCheck(server, session) {\n        return new Promise((resolve, reject) => {\n            const db = this.db;\n            const name = this.name;\n            const options = this.options;\n            const done = err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(new collection_1.Collection(db, name, options));\n            };\n            const cmd = { create: name };\n            for (const n in options) {\n                if (options[n] != null &&\n                    typeof options[n] !== 'function' &&\n                    !ILLEGAL_COMMAND_FIELDS.has(n)) {\n                    cmd[n] = options[n];\n                }\n            }\n            // otherwise just execute the command\n            super.executeCommand(server, session, cmd, done);\n        });\n    }\n}\nexports.CreateCollectionOperation = CreateCollectionOperation;\n(0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=create_collection.js.map"]},"metadata":{},"sourceType":"script"}