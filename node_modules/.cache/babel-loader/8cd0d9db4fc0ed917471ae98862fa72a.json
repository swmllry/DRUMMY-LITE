{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n\nconst exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\n\nclass MapReduceOperation extends command_1.CommandOperation {\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  constructor(collection, map, reduce, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.map = map;\n    this.reduce = reduce;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const map = this.map;\n    const reduce = this.reduce;\n    let options = this.options;\n    const mapCommandHash = {\n      mapReduce: coll.collectionName,\n      map: map,\n      reduce: reduce\n    };\n\n    if (options.scope) {\n      mapCommandHash.scope = processScope(options.scope);\n    } // Add any other options passed in\n\n\n    for (const n in options) {\n      // Only include if not in exclusion list\n      if (exclusionList.indexOf(n) === -1) {\n        mapCommandHash[n] = options[n];\n      }\n    }\n\n    options = Object.assign({}, options); // If we have a read preference and inline is not set as output fail hard\n\n    if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n      // Force readPreference to primary\n      options.readPreference = read_preference_1.ReadPreference.primary; // Decorate command with writeConcern if supported\n\n      (0, utils_1.applyWriteConcern)(mapCommandHash, {\n        db: coll.s.db,\n        collection: coll\n      }, options);\n    } else {\n      (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n    } // Is bypassDocumentValidation specified\n\n\n    if (options.bypassDocumentValidation === true) {\n      mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // Have we specified collation\n\n\n    try {\n      (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n    } catch (err) {\n      return callback(err);\n    }\n\n    if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n      return;\n    } // Execute command\n\n\n    super.executeCommand(server, session, mapCommandHash, (err, result) => {\n      if (err) return callback(err); // Check if we have an error\n\n      if (1 !== result.ok || result.err || result.errmsg) {\n        return callback(new error_1.MongoServerError(result));\n      } // If an explain option was executed, don't process the server results\n\n\n      if (this.explain) return callback(undefined, result); // Create statistics value\n\n      const stats = {};\n      if (result.timeMillis) stats['processtime'] = result.timeMillis;\n      if (result.counts) stats['counts'] = result.counts;\n      if (result.timing) stats['timing'] = result.timing; // invoked with inline?\n\n      if (result.results) {\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(undefined, result.results);\n        }\n\n        return callback(undefined, {\n          results: result.results,\n          stats: stats\n        });\n      } // The returned collection\n\n\n      let collection = null; // If we have an object it's a different db\n\n      if (result.result != null && typeof result.result === 'object') {\n        const doc = result.result; // Return a collection from another db\n\n        collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n      } else {\n        // Create a collection object that wraps the result collection\n        collection = coll.s.db.collection(result.result);\n      } // If we wish for no verbosity\n\n\n      if (options['verbose'] == null || !options['verbose']) {\n        return callback(err, collection);\n      } // Return stats as third set of values\n\n\n      callback(err, {\n        collection,\n        stats\n      });\n    });\n  }\n\n}\n\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\n\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n\n  const newScope = {};\n\n  for (const key of Object.keys(scope)) {\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n\n  return newScope;\n}\n\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"sources":["../../src/operations/map_reduce.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapReduceOperation = void 0;\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\nconst exclusionList = [\n    'explain',\n    'readPreference',\n    'readConcern',\n    'session',\n    'bypassDocumentValidation',\n    'writeConcern',\n    'raw',\n    'fieldsAsRaw',\n    'promoteLongs',\n    'promoteValues',\n    'promoteBuffers',\n    'bsonRegExp',\n    'serializeFunctions',\n    'ignoreUndefined',\n    'enableUtf8Validation',\n    'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nclass MapReduceOperation extends command_1.CommandOperation {\n    /**\n     * Constructs a MapReduce operation.\n     *\n     * @param collection - Collection instance.\n     * @param map - The mapping function.\n     * @param reduce - The reduce function.\n     * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n     */\n    constructor(collection, map, reduce, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collection = collection;\n        this.map = map;\n        this.reduce = reduce;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const map = this.map;\n        const reduce = this.reduce;\n        let options = this.options;\n        const mapCommandHash = {\n            mapReduce: coll.collectionName,\n            map: map,\n            reduce: reduce\n        };\n        if (options.scope) {\n            mapCommandHash.scope = processScope(options.scope);\n        }\n        // Add any other options passed in\n        for (const n in options) {\n            // Only include if not in exclusion list\n            if (exclusionList.indexOf(n) === -1) {\n                mapCommandHash[n] = options[n];\n            }\n        }\n        options = Object.assign({}, options);\n        // If we have a read preference and inline is not set as output fail hard\n        if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary &&\n            options.out &&\n            options.out.inline !== 1 &&\n            options.out !== 'inline') {\n            // Force readPreference to primary\n            options.readPreference = read_preference_1.ReadPreference.primary;\n            // Decorate command with writeConcern if supported\n            (0, utils_1.applyWriteConcern)(mapCommandHash, { db: coll.s.db, collection: coll }, options);\n        }\n        else {\n            (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n        }\n        // Is bypassDocumentValidation specified\n        if (options.bypassDocumentValidation === true) {\n            mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n        }\n        // Have we specified collation\n        try {\n            (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n        }\n        catch (err) {\n            return callback(err);\n        }\n        if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n            callback(new error_1.MongoCompatibilityError(`Server ${server.name} does not support explain on mapReduce`));\n            return;\n        }\n        // Execute command\n        super.executeCommand(server, session, mapCommandHash, (err, result) => {\n            if (err)\n                return callback(err);\n            // Check if we have an error\n            if (1 !== result.ok || result.err || result.errmsg) {\n                return callback(new error_1.MongoServerError(result));\n            }\n            // If an explain option was executed, don't process the server results\n            if (this.explain)\n                return callback(undefined, result);\n            // Create statistics value\n            const stats = {};\n            if (result.timeMillis)\n                stats['processtime'] = result.timeMillis;\n            if (result.counts)\n                stats['counts'] = result.counts;\n            if (result.timing)\n                stats['timing'] = result.timing;\n            // invoked with inline?\n            if (result.results) {\n                // If we wish for no verbosity\n                if (options['verbose'] == null || !options['verbose']) {\n                    return callback(undefined, result.results);\n                }\n                return callback(undefined, { results: result.results, stats: stats });\n            }\n            // The returned collection\n            let collection = null;\n            // If we have an object it's a different db\n            if (result.result != null && typeof result.result === 'object') {\n                const doc = result.result;\n                // Return a collection from another db\n                collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n            }\n            else {\n                // Create a collection object that wraps the result collection\n                collection = coll.s.db.collection(result.result);\n            }\n            // If we wish for no verbosity\n            if (options['verbose'] == null || !options['verbose']) {\n                return callback(err, collection);\n            }\n            // Return stats as third set of values\n            callback(err, { collection, stats });\n        });\n    }\n}\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n    if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n        return scope;\n    }\n    const newScope = {};\n    for (const key of Object.keys(scope)) {\n        if ('function' === typeof scope[key]) {\n            newScope[key] = new bson_1.Code(String(scope[key]));\n        }\n        else if (scope[key]._bsontype === 'Code') {\n            newScope[key] = scope[key];\n        }\n        else {\n            newScope[key] = processScope(scope[key]);\n        }\n    }\n    return newScope;\n}\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);\n//# sourceMappingURL=map_reduce.js.map"]},"metadata":{},"sourceType":"script"}