{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\n\nconst change_stream_1 = require(\"../change_stream\");\n\nconst constants_1 = require(\"../constants\");\n\nconst aggregate_1 = require(\"../operations/aggregate\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\n\n\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(client, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const options = { ...this.options\n    };\n\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n      delete options[key];\n    }\n\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n\n    return options;\n  }\n\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n\n    this.hasReceived = true;\n  }\n\n  _processBatch(response) {\n    const cursor = response.cursor;\n\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n      const batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone() {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, { ...this.cursorOptions\n    });\n  }\n\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n\n      const server = aggregateOperation.server;\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch(response);\n\n      this.emit(constants_1.INIT, response);\n      this.emit(constants_1.RESPONSE); // TODO: NODE-2882\n\n      callback(undefined, {\n        server,\n        session,\n        response\n      });\n    });\n  }\n\n  _getMore(batchSize, callback) {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n\n      this._processBatch(response);\n\n      this.emit(change_stream_1.ChangeStream.MORE, response);\n      this.emit(change_stream_1.ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n\n}\n\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"sources":["../../src/cursor/change_stream_cursor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChangeStreamCursor = void 0;\nconst change_stream_1 = require(\"../change_stream\");\nconst constants_1 = require(\"../constants\");\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n    constructor(client, namespace, pipeline = [], options = {}) {\n        super(client, namespace, options);\n        this.pipeline = pipeline;\n        this.options = options;\n        this._resumeToken = null;\n        this.startAtOperationTime = options.startAtOperationTime;\n        if (options.startAfter) {\n            this.resumeToken = options.startAfter;\n        }\n        else if (options.resumeAfter) {\n            this.resumeToken = options.resumeAfter;\n        }\n    }\n    set resumeToken(token) {\n        this._resumeToken = token;\n        this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n    }\n    get resumeToken() {\n        return this._resumeToken;\n    }\n    get resumeOptions() {\n        const options = {\n            ...this.options\n        };\n        for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n            delete options[key];\n        }\n        if (this.resumeToken != null) {\n            if (this.options.startAfter && !this.hasReceived) {\n                options.startAfter = this.resumeToken;\n            }\n            else {\n                options.resumeAfter = this.resumeToken;\n            }\n        }\n        else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n            options.startAtOperationTime = this.startAtOperationTime;\n        }\n        return options;\n    }\n    cacheResumeToken(resumeToken) {\n        if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n            this.resumeToken = this.postBatchResumeToken;\n        }\n        else {\n            this.resumeToken = resumeToken;\n        }\n        this.hasReceived = true;\n    }\n    _processBatch(response) {\n        const cursor = response.cursor;\n        if (cursor.postBatchResumeToken) {\n            this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n            const batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n            if (batch.length === 0) {\n                this.resumeToken = cursor.postBatchResumeToken;\n            }\n        }\n    }\n    clone() {\n        return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n            ...this.cursorOptions\n        });\n    }\n    _initialize(session, callback) {\n        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n            ...this.cursorOptions,\n            ...this.options,\n            session\n        });\n        (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {\n            if (err || response == null) {\n                return callback(err);\n            }\n            const server = aggregateOperation.server;\n            this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n            if (this.startAtOperationTime == null &&\n                this.resumeAfter == null &&\n                this.startAfter == null &&\n                this.maxWireVersion >= 7) {\n                this.startAtOperationTime = response.operationTime;\n            }\n            this._processBatch(response);\n            this.emit(constants_1.INIT, response);\n            this.emit(constants_1.RESPONSE);\n            // TODO: NODE-2882\n            callback(undefined, { server, session, response });\n        });\n    }\n    _getMore(batchSize, callback) {\n        super._getMore(batchSize, (err, response) => {\n            if (err) {\n                return callback(err);\n            }\n            this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n            this._processBatch(response);\n            this.emit(change_stream_1.ChangeStream.MORE, response);\n            this.emit(change_stream_1.ChangeStream.RESPONSE);\n            callback(err, response);\n        });\n    }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;\n//# sourceMappingURL=change_stream_cursor.js.map"]},"metadata":{},"sourceType":"script"}