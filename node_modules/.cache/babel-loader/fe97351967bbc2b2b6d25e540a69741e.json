{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\n\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst server_description_1 = require(\"./server_description\"); // constants related to compatibility checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    var _a, _b;\n\n    options = options !== null && options !== void 0 ? options : {};\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;\n\n    if (setName) {\n      this.setName = setName;\n    }\n\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    } // determine server compatibility\n\n\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = undefined;\n\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    let srvMaxHosts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n    const hostnamesToAdd = new Set(incomingHostnames);\n    const hostnamesToRemove = new Set();\n\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // potentially mutated values\n\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      // TODO(NODE-4159): servers with an incorrect setName should be removed not marked Unknown\n      serverDescription = new server_description_1.ServerDescription(address, undefined);\n    }\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return;\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nexports.TopologyDescription = TopologyDescription;\n\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n} // TODO: improve these docs when ObjectId is properly typed\n\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"sources":["../../src/sdam/topology_description.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TopologyDescription = void 0;\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst server_description_1 = require(\"./server_description\");\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([\n    common_1.ServerType.RSSecondary,\n    common_1.ServerType.RSArbiter,\n    common_1.ServerType.RSOther\n]);\n/**\n * Representation of a deployment of servers\n * @public\n */\nclass TopologyDescription {\n    /**\n     * Create a TopologyDescription\n     */\n    constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n        var _a, _b;\n        options = options !== null && options !== void 0 ? options : {};\n        this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n        this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n        this.stale = false;\n        this.compatible = true;\n        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n        this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 15;\n        if (setName) {\n            this.setName = setName;\n        }\n        if (maxSetVersion) {\n            this.maxSetVersion = maxSetVersion;\n        }\n        if (maxElectionId) {\n            this.maxElectionId = maxElectionId;\n        }\n        if (commonWireVersion) {\n            this.commonWireVersion = commonWireVersion;\n        }\n        // determine server compatibility\n        for (const serverDescription of this.servers.values()) {\n            // Load balancer mode is always compatible.\n            if (serverDescription.type === common_1.ServerType.Unknown ||\n                serverDescription.type === common_1.ServerType.LoadBalancer) {\n                continue;\n            }\n            if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n            }\n            if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n                break;\n            }\n        }\n        // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n        // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n        // value among ServerDescriptions of all data-bearing server types. If any have a null\n        // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n        // set to null.\n        this.logicalSessionTimeoutMinutes = undefined;\n        for (const [, server] of this.servers) {\n            if (server.isReadable) {\n                if (server.logicalSessionTimeoutMinutes == null) {\n                    // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n                    this.logicalSessionTimeoutMinutes = undefined;\n                    break;\n                }\n                if (this.logicalSessionTimeoutMinutes == null) {\n                    // First server with a non null logicalSessionsTimeout\n                    this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n                    continue;\n                }\n                // Always select the smaller of the:\n                // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n                this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n            }\n        }\n    }\n    /**\n     * Returns a new TopologyDescription based on the SrvPollingEvent\n     * @internal\n     */\n    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {\n        /** The SRV addresses defines the set of addresses we should be using */\n        const incomingHostnames = ev.hostnames();\n        const currentHostnames = new Set(this.servers.keys());\n        const hostnamesToAdd = new Set(incomingHostnames);\n        const hostnamesToRemove = new Set();\n        for (const hostname of currentHostnames) {\n            // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n            hostnamesToAdd.delete(hostname);\n            if (!incomingHostnames.has(hostname)) {\n                // If the SRV Records no longer include this hostname\n                // we have to stop using it\n                hostnamesToRemove.add(hostname);\n            }\n        }\n        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n            // No new hosts to add and none to remove\n            return this;\n        }\n        const serverDescriptions = new Map(this.servers);\n        for (const removedHost of hostnamesToRemove) {\n            serverDescriptions.delete(removedHost);\n        }\n        if (hostnamesToAdd.size > 0) {\n            if (srvMaxHosts === 0) {\n                // Add all!\n                for (const hostToAdd of hostnamesToAdd) {\n                    serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));\n                }\n            }\n            else if (serverDescriptions.size < srvMaxHosts) {\n                // Add only the amount needed to get us back to srvMaxHosts\n                const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n                for (const selectedHostToAdd of selectedHosts) {\n                    serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));\n                }\n            }\n        }\n        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     * @internal\n     */\n    update(serverDescription) {\n        const address = serverDescription.address;\n        // potentially mutated values\n        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n        if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n            // TODO(NODE-4159): servers with an incorrect setName should be removed not marked Unknown\n            serverDescription = new server_description_1.ServerDescription(address, undefined);\n        }\n        const serverType = serverDescription.type;\n        const serverDescriptions = new Map(this.servers);\n        // update common wire version\n        if (serverDescription.maxWireVersion !== 0) {\n            if (commonWireVersion == null) {\n                commonWireVersion = serverDescription.maxWireVersion;\n            }\n            else {\n                commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n            }\n        }\n        // update the actual server description\n        serverDescriptions.set(address, serverDescription);\n        if (topologyType === common_1.TopologyType.Single) {\n            // once we are defined as single, that never changes\n            return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n        }\n        if (topologyType === common_1.TopologyType.Unknown) {\n            if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n                serverDescriptions.delete(address);\n            }\n            else {\n                topologyType = topologyTypeForServerType(serverType);\n            }\n        }\n        if (topologyType === common_1.TopologyType.Sharded) {\n            if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n            if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n                topologyType = result[0];\n                setName = result[1];\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n            else if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n            }\n            else {\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n        }\n        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    get error() {\n        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);\n        if (descriptionsWithError.length > 0) {\n            return descriptionsWithError[0].error;\n        }\n        return;\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n    get hasKnownServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n    get hasDataBearingServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);\n    }\n    /**\n     * Determines if the topology has a definition for the provided address\n     * @internal\n     */\n    hasServer(address) {\n        return this.servers.has(address);\n    }\n}\nexports.TopologyDescription = TopologyDescription;\nfunction topologyTypeForServerType(serverType) {\n    switch (serverType) {\n        case common_1.ServerType.Standalone:\n            return common_1.TopologyType.Single;\n        case common_1.ServerType.Mongos:\n            return common_1.TopologyType.Sharded;\n        case common_1.ServerType.RSPrimary:\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        case common_1.ServerType.RSOther:\n        case common_1.ServerType.RSSecondary:\n            return common_1.TopologyType.ReplicaSetNoPrimary;\n        default:\n            return common_1.TopologyType.Unknown;\n    }\n}\n// TODO: improve these docs when ObjectId is properly typed\nfunction compareObjectId(oid1, oid2) {\n    if (oid1 == null) {\n        return -1;\n    }\n    if (oid2 == null) {\n        return 1;\n    }\n    if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n        const oid1Buffer = oid1.id;\n        const oid2Buffer = oid2.id;\n        return oid1Buffer.compare(oid2Buffer);\n    }\n    const oid1String = oid1.toString();\n    const oid2String = oid2.toString();\n    return oid1String.localeCompare(oid2String);\n}\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n        if (maxSetVersion && maxElectionId) {\n            if (maxSetVersion > serverDescription.setVersion ||\n                compareObjectId(maxElectionId, electionId) > 0) {\n                // this primary is stale, we must remove it\n                serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n                return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n            }\n        }\n        maxElectionId = serverDescription.electionId;\n    }\n    if (serverDescription.setVersion != null &&\n        (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n        maxSetVersion = serverDescription.setVersion;\n    }\n    // We've heard from the primary. Is it the same primary as before?\n    for (const [address, server] of serverDescriptions) {\n        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n            // Reset old primary's type to Unknown.\n            serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));\n            // There can only be one primary\n            break;\n        }\n    }\n    // Discover new hosts from this primary's response.\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    // Remove hosts not in the response.\n    const currentAddresses = Array.from(serverDescriptions.keys());\n    const responseAddresses = serverDescription.allHosts;\n    currentAddresses\n        .filter((addr) => responseAddresses.indexOf(addr) === -1)\n        .forEach((address) => {\n        serverDescriptions.delete(address);\n    });\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    if (setName == null) {\n        // TODO(NODE-3483): should be an appropriate runtime error\n        throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n    }\n    if (setName !== serverDescription.setName ||\n        (serverDescription.me && serverDescription.address !== serverDescription.me)) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [topologyType, setName];\n    }\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n    for (const serverDescription of serverDescriptions.values()) {\n        if (serverDescription.type === common_1.ServerType.RSPrimary) {\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        }\n    }\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n}\n//# sourceMappingURL=topology_description.js.map"]},"metadata":{},"sourceType":"script"}