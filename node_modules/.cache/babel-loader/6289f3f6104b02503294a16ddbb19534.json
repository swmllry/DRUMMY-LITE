{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst metrics_1 = require(\"./cmap/metrics\");\n\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nconst constants_1 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst transactions_1 = require(\"./transactions\");\n\nconst utils_1 = require(\"./utils\");\n\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\n\nconst kServerSession = Symbol('serverSession');\n/** @internal */\n\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\n\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n\n    this[_a] = false;\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n\n\n  get id() {\n    var _b;\n\n    return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;\n  }\n\n  get serverSession() {\n    let serverSession = this[kServerSession];\n\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n\n\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced() {\n    var _b;\n\n    return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n\n\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n\n\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n\n\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const finalOptions = {\n      force: true,\n      ...options\n    };\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this.hasEnded) {\n        maybeClearPinnedConnection(this, finalOptions);\n        return done();\n      }\n\n      const completeEndSession = () => {\n        maybeClearPinnedConnection(this, finalOptions);\n        const serverSession = this[kServerSession];\n\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession); // Make sure a new serverSession never makes it onto this ClientSession\n\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        } // mark the session as ended, and emit a signal\n\n\n        this.hasEnded = true;\n        this.emit('ended', this); // spec indicates that we should ignore all errors for `endSessions`\n\n        done();\n      };\n\n      if (this.inTransaction()) {\n        // If we've reached endSession and the transaction is still active\n        // by default we abort it\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n\n\n  advanceClusterTime(clusterTime) {\n    var _b, _c;\n\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n\n    if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n\n\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n\n  commitTransaction(callback) {\n    return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n\n  abortTransaction(callback) {\n    return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n\n\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   * Any callbacks that do not return a Promise will result in undefined behavior.\n   *\n   * @remarks\n   * This function:\n   * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n   * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n   * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n\n  const topology = session.client.topology; // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear(conn.serviceId);\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(() => null);\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n\n      throw err;\n    }\n\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(error, result) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (error instanceof error_1.MongoError) {\n      if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error\n        });\n      }\n    }\n\n    callback(error, result);\n  }\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (error, result) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n\n    commandHandler(error, result);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n\n\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type); // Manual prototype construction to avoid modifying the constructor of this class\n\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n\n}\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = [];\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n\n\n  acquire() {\n    var _b, _c, _d;\n\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n    let session = null; // Try to obtain from session pool\n\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n\n      if (potentialSession != null && (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    } // If nothing valid came from the pool make a new one\n\n\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n\n\n  release(session) {\n    var _b, _c, _d;\n\n    const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n\n    if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n}\n\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\n\nfunction applySession(session, command, options) {\n  var _b, _c;\n\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  } // May acquire serverSession here\n\n\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n\n  return;\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"sources":["../src/sessions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n    /**\n     * Create a client session.\n     * @internal\n     * @param client - The current client\n     * @param sessionPool - The server session pool (Internal Class)\n     * @param options - Optional settings\n     * @param clientOptions - Optional settings provided when creating a MongoClient\n     */\n    constructor(client, sessionPool, options, clientOptions) {\n        super();\n        /** @internal */\n        this[_a] = false;\n        if (client == null) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n        }\n        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n        }\n        options = options !== null && options !== void 0 ? options : {};\n        if (options.snapshot === true) {\n            this[kSnapshotEnabled] = true;\n            if (options.causalConsistency === true) {\n                throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n            }\n        }\n        this.client = client;\n        this.sessionPool = sessionPool;\n        this.hasEnded = false;\n        this.clientOptions = clientOptions;\n        this.explicit = !!options.explicit;\n        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n        this[kTxnNumberIncrement] = 0;\n        this.supports = {\n            causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n        };\n        this.clusterTime = options.initialClusterTime;\n        this.operationTime = undefined;\n        this.owner = options.owner;\n        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n        this.transaction = new transactions_1.Transaction();\n    }\n    /** The server id associated with this session */\n    get id() {\n        var _b;\n        return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;\n    }\n    get serverSession() {\n        let serverSession = this[kServerSession];\n        if (serverSession == null) {\n            if (this.explicit) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n            }\n            if (this.hasEnded) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n            }\n            serverSession = this.sessionPool.acquire();\n            this[kServerSession] = serverSession;\n        }\n        return serverSession;\n    }\n    /** Whether or not this session is configured for snapshot reads */\n    get snapshotEnabled() {\n        return this[kSnapshotEnabled];\n    }\n    get loadBalanced() {\n        var _b;\n        return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n    get pinnedConnection() {\n        return this[kPinnedConnection];\n    }\n    /** @internal */\n    pin(conn) {\n        if (this[kPinnedConnection]) {\n            throw TypeError('Cannot pin multiple connections to the same session');\n        }\n        this[kPinnedConnection] = conn;\n        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n    unpin(options) {\n        if (this.loadBalanced) {\n            return maybeClearPinnedConnection(this, options);\n        }\n        this.transaction.unpinServer();\n    }\n    get isPinned() {\n        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n    endSession(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        const finalOptions = { force: true, ...options };\n        return (0, utils_1.maybePromise)(callback, done => {\n            if (this.hasEnded) {\n                maybeClearPinnedConnection(this, finalOptions);\n                return done();\n            }\n            const completeEndSession = () => {\n                maybeClearPinnedConnection(this, finalOptions);\n                const serverSession = this[kServerSession];\n                if (serverSession != null) {\n                    // release the server session back to the pool\n                    this.sessionPool.release(serverSession);\n                    // Make sure a new serverSession never makes it onto this ClientSession\n                    Object.defineProperty(this, kServerSession, {\n                        value: ServerSession.clone(serverSession),\n                        writable: false\n                    });\n                }\n                // mark the session as ended, and emit a signal\n                this.hasEnded = true;\n                this.emit('ended', this);\n                // spec indicates that we should ignore all errors for `endSessions`\n                done();\n            };\n            if (this.inTransaction()) {\n                // If we've reached endSession and the transaction is still active\n                // by default we abort it\n                this.abortTransaction(err => {\n                    if (err)\n                        return done(err);\n                    completeEndSession();\n                });\n                return;\n            }\n            completeEndSession();\n        });\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n    advanceOperationTime(operationTime) {\n        if (this.operationTime == null) {\n            this.operationTime = operationTime;\n            return;\n        }\n        if (operationTime.greaterThan(this.operationTime)) {\n            this.operationTime = operationTime;\n        }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n    advanceClusterTime(clusterTime) {\n        var _b, _c;\n        if (!clusterTime || typeof clusterTime !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n        }\n        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n        }\n        if (!clusterTime.signature ||\n            ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' ||\n            (typeof clusterTime.signature.keyId !== 'number' &&\n                ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long') // apparently we decode the key to number?\n        ) {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n        }\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n    equals(session) {\n        if (!(session instanceof ClientSession)) {\n            return false;\n        }\n        if (this.id == null || session.id == null) {\n            return false;\n        }\n        return this.id.id.buffer.equals(session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     *\n     * @privateRemarks\n     * This helper increments a value stored on the client session that will be\n     * added to the serverSession's txnNumber upon applying it to a command.\n     * This is because the serverSession is lazily acquired after a connection is obtained\n     */\n    incrementTransactionNumber() {\n        this[kTxnNumberIncrement] += 1;\n    }\n    /** @returns whether this session is currently in a transaction or not */\n    inTransaction() {\n        return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n    startTransaction(options) {\n        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        if (this[kSnapshotEnabled]) {\n            throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n        }\n        if (this.inTransaction()) {\n            throw new error_1.MongoTransactionError('Transaction already in progress');\n        }\n        if (this.isPinned && this.transaction.isCommitted) {\n            this.unpin();\n        }\n        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n        if ((0, shared_1.isSharded)(this.client.topology) &&\n            topologyMaxWireVersion != null &&\n            topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n        }\n        // increment txnNumber\n        this.incrementTransactionNumber();\n        // create transaction state\n        this.transaction = new transactions_1.Transaction({\n            readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n            writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n            readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n            maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n        });\n        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    commitTransaction(callback) {\n        return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'commitTransaction', cb));\n    }\n    abortTransaction(callback) {\n        return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'abortTransaction', cb));\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n    toBSON() {\n        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Runs a provided callback within a transaction, retrying either the commitTransaction operation\n     * or entire transaction as needed (and when the error permits) to better ensure that\n     * the transaction can complete successfully.\n     *\n     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n     * Any callbacks that do not return a Promise will result in undefined behavior.\n     *\n     * @remarks\n     * This function:\n     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)\n     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`\n     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback\n     *\n     * Checkout a descriptive example here:\n     * @see https://www.mongodb.com/developer/quickstart/node-transactions/\n     *\n     * @param fn - callback to run within a transaction\n     * @param options - optional settings for the transaction\n     * @returns A raw command response or undefined\n     */\n    withTransaction(fn, options) {\n        const startTime = (0, utils_1.now)();\n        return attemptTransaction(this, startTime, fn, options);\n    }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n    'CannotSatisfyWriteConcern',\n    'UnknownReplWriteConcern',\n    'UnsatisfiableWriteConcern'\n]);\nfunction hasNotTimedOut(startTime, max) {\n    return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&\n        err.codeName &&\n        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n    return (isMaxTimeMSExpiredError(err) ||\n        (!isNonDeterministicWriteConcernError &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));\n}\nfunction maybeClearPinnedConnection(session, options) {\n    // unpin a connection if it has been pinned\n    const conn = session[kPinnedConnection];\n    const error = options === null || options === void 0 ? void 0 : options.error;\n    if (session.inTransaction() &&\n        error &&\n        error instanceof error_1.MongoError &&\n        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return;\n    }\n    const topology = session.client.topology;\n    // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n    //       to validate that we don't unpin on _all_ errors?\n    if (conn && topology != null) {\n        const servers = Array.from(topology.s.servers.values());\n        const loadBalancer = servers[0];\n        if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n            loadBalancer.s.pool.checkIn(conn);\n            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION\n                ? metrics_1.ConnectionPoolMetrics.TXN\n                : metrics_1.ConnectionPoolMetrics.CURSOR);\n            if (options === null || options === void 0 ? void 0 : options.forceClear) {\n                loadBalancer.s.pool.clear(conn.serviceId);\n            }\n        }\n        session[kPinnedConnection] = undefined;\n    }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n    if (err == null || !(err instanceof error_1.MongoServerError)) {\n        return false;\n    }\n    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n        (err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired));\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n    return session.commitTransaction().catch((err) => {\n        if (err instanceof error_1.MongoError &&\n            hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n            !isMaxTimeMSExpiredError(err)) {\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n                return attemptTransactionCommit(session, startTime, fn, options);\n            }\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n        }\n        throw err;\n    });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n    transactions_1.TxnState.NO_TRANSACTION,\n    transactions_1.TxnState.TRANSACTION_COMMITTED,\n    transactions_1.TxnState.TRANSACTION_ABORTED\n]);\nfunction userExplicitlyEndedTransaction(session) {\n    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    session.startTransaction(options);\n    let promise;\n    try {\n        promise = fn(session);\n    }\n    catch (err) {\n        promise = Promise.reject(err);\n    }\n    if (!(0, utils_1.isPromiseLike)(promise)) {\n        session.abortTransaction().catch(() => null);\n        throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n    }\n    return promise.then(() => {\n        if (userExplicitlyEndedTransaction(session)) {\n            return;\n        }\n        return attemptTransactionCommit(session, startTime, fn, options);\n    }, err => {\n        function maybeRetryOrThrow(err) {\n            if (err instanceof error_1.MongoError &&\n                err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&\n                hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n            if (isMaxTimeMSExpiredError(err)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n            }\n            throw err;\n        }\n        if (session.inTransaction()) {\n            return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n        }\n        return maybeRetryOrThrow(err);\n    });\n}\nfunction endTransaction(session, commandName, callback) {\n    // handle any initial problematic cases\n    const txnState = session.transaction.state;\n    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n        callback(new error_1.MongoTransactionError('No transaction started'));\n        return;\n    }\n    if (commandName === 'commitTransaction') {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n            return;\n        }\n    }\n    else {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n            return;\n        }\n    }\n    // construct and send the command\n    const command = { [commandName]: 1 };\n    // apply a writeConcern if specified\n    let writeConcern;\n    if (session.transaction.options.writeConcern) {\n        writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n    }\n    else if (session.clientOptions && session.clientOptions.writeConcern) {\n        writeConcern = { w: session.clientOptions.writeConcern.w };\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n        writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n    }\n    if (writeConcern) {\n        Object.assign(command, { writeConcern });\n    }\n    if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n    }\n    function commandHandler(error, result) {\n        if (commandName !== 'commitTransaction') {\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            if (session.loadBalanced) {\n                maybeClearPinnedConnection(session, { force: false });\n            }\n            // The spec indicates that we should ignore all errors on `abortTransaction`\n            return callback();\n        }\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n        if (error instanceof error_1.MongoError) {\n            if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) ||\n                error instanceof error_1.MongoWriteConcernError ||\n                isMaxTimeMSExpiredError(error)) {\n                if (isUnknownTransactionCommitResult(error)) {\n                    error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n                    // per txns spec, must unpin session in this case\n                    session.unpin({ error });\n                }\n            }\n            else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                session.unpin({ error });\n            }\n        }\n        callback(error, result);\n    }\n    if (session.transaction.recoveryToken) {\n        command.recoveryToken = session.transaction.recoveryToken;\n    }\n    // send the command\n    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n    }), (error, result) => {\n        if (command.abortTransaction) {\n            // always unpin on abort regardless of command outcome\n            session.unpin();\n        }\n        if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {\n            // SPEC-1185: apply majority write concern when retrying commitTransaction\n            if (command.commitTransaction) {\n                // per txns spec, must unpin session in this case\n                session.unpin({ force: true });\n                command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n                    w: 'majority'\n                });\n            }\n            return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {\n                session,\n                readPreference: read_preference_1.ReadPreference.primary,\n                bypassPinningCheck: true\n            }), commandHandler);\n        }\n        commandHandler(error, result);\n    });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n    /** @internal */\n    constructor() {\n        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };\n        this.lastUse = (0, utils_1.now)();\n        this.txnNumber = 0;\n        this.isDirty = false;\n    }\n    /**\n     * Determines if the server session has timed out.\n     *\n     * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n     */\n    hasTimedOut(sessionTimeoutMinutes) {\n        // Take the difference of the lastUse timestamp and now, which will result in a value in\n        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n        const idleTimeMinutes = Math.round((((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000) % 3600000) / 60000);\n        return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n    /**\n     * @internal\n     * Cloning meant to keep a readable reference to the server session data\n     * after ClientSession has ended\n     */\n    static clone(serverSession) {\n        const arrayBuffer = new ArrayBuffer(16);\n        const idBytes = Buffer.from(arrayBuffer);\n        idBytes.set(serverSession.id.id.buffer);\n        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n        // Manual prototype construction to avoid modifying the constructor of this class\n        return Object.setPrototypeOf({\n            id: { id },\n            lastUse: serverSession.lastUse,\n            txnNumber: serverSession.txnNumber,\n            isDirty: serverSession.isDirty\n        }, ServerSession.prototype);\n    }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n    constructor(client) {\n        if (client == null) {\n            throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n        }\n        this.client = client;\n        this.sessions = [];\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession is created.\n     */\n    acquire() {\n        var _b, _c, _d;\n        const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n        let session = null;\n        // Try to obtain from session pool\n        while (this.sessions.length > 0) {\n            const potentialSession = this.sessions.shift();\n            if (potentialSession != null &&\n                (!!((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) ||\n                    !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n                session = potentialSession;\n                break;\n            }\n        }\n        // If nothing valid came from the pool make a new one\n        if (session == null) {\n            session = new ServerSession();\n        }\n        return session;\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n    release(session) {\n        var _b, _c, _d;\n        const sessionTimeoutMinutes = (_c = (_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.logicalSessionTimeoutMinutes) !== null && _c !== void 0 ? _c : 10;\n        if (((_d = this.client.topology) === null || _d === void 0 ? void 0 : _d.loadBalanced) && !sessionTimeoutMinutes) {\n            this.sessions.unshift(session);\n        }\n        if (!sessionTimeoutMinutes) {\n            return;\n        }\n        while (this.sessions.length) {\n            const pooledSession = this.sessions[this.sessions.length - 1];\n            if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n                this.sessions.pop();\n            }\n            else {\n                break;\n            }\n        }\n        if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n            if (session.isDirty) {\n                return;\n            }\n            // otherwise, readd this session to the session pool\n            this.sessions.unshift(session);\n        }\n    }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n    var _b, _c;\n    if (session.hasEnded) {\n        return new error_1.MongoExpiredSessionError();\n    }\n    // May acquire serverSession here\n    const serverSession = session.serverSession;\n    if (serverSession == null) {\n        return new error_1.MongoRuntimeError('Unable to acquire server session');\n    }\n    if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {\n        if (session && session.explicit) {\n            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n        }\n        return;\n    }\n    // mark the last use of this session, and apply the `lsid`\n    serverSession.lastUse = (0, utils_1.now)();\n    command.lsid = serverSession.id;\n    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n    const isRetryableWrite = !!options.willRetryWrite;\n    if (isRetryableWrite || inTxnOrTxnCommand) {\n        serverSession.txnNumber += session[kTxnNumberIncrement];\n        session[kTxnNumberIncrement] = 0;\n        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n    }\n    if (!inTxnOrTxnCommand) {\n        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n        }\n        if (session.supports.causalConsistency &&\n            session.operationTime &&\n            (0, utils_1.commandSupportsReadConcern)(command, options)) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n        else if (session[kSnapshotEnabled]) {\n            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };\n            if (session[kSnapshotTime] != null) {\n                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n            }\n        }\n        return;\n    }\n    // now attempt to apply transaction-specific sessions data\n    // `autocommit` must always be false to differentiate from retryable writes\n    command.autocommit = false;\n    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n        command.startTransaction = true;\n        const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);\n        if (readConcern) {\n            command.readConcern = readConcern;\n        }\n        if (session.supports.causalConsistency && session.operationTime) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n    }\n    return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n    var _b;\n    if (document.$clusterTime) {\n        (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n    }\n    if (document.operationTime && session && session.supports.causalConsistency) {\n        session.advanceOperationTime(document.operationTime);\n    }\n    if (document.recoveryToken && session && session.inTransaction()) {\n        session.transaction._recoveryToken = document.recoveryToken;\n    }\n    if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n        // find and aggregate commands return atClusterTime on the cursor\n        // distinct includes it in the response body\n        const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n        if (atClusterTime) {\n            session[kSnapshotTime] = atClusterTime;\n        }\n    }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;\n//# sourceMappingURL=sessions.js.map"]},"metadata":{},"sourceType":"script"}