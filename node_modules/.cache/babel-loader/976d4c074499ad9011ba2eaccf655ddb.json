{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst ordered_1 = require(\"./bulk/ordered\");\n\nconst unordered_1 = require(\"./bulk/unordered\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\n\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n\nconst list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\n\nconst error_1 = require(\"./error\");\n\nconst bulk_write_1 = require(\"./operations/bulk_write\");\n\nconst count_1 = require(\"./operations/count\");\n\nconst count_documents_1 = require(\"./operations/count_documents\");\n\nconst delete_1 = require(\"./operations/delete\");\n\nconst distinct_1 = require(\"./operations/distinct\");\n\nconst drop_1 = require(\"./operations/drop\");\n\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\n\nconst indexes_1 = require(\"./operations/indexes\");\n\nconst insert_1 = require(\"./operations/insert\");\n\nconst is_capped_1 = require(\"./operations/is_capped\");\n\nconst map_reduce_1 = require(\"./operations/map_reduce\");\n\nconst options_operation_1 = require(\"./operations/options_operation\");\n\nconst rename_1 = require(\"./operations/rename\");\n\nconst stats_1 = require(\"./operations/stats\");\n\nconst update_1 = require(\"./operations/update\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst utils_1 = require(\"./utils\");\n\nconst write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\n\n\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    var _a, _b;\n\n    (0, utils_1.checkCollectionName)(name); // Internal state\n\n    this.s = {\n      db,\n      options,\n      namespace: new utils_1.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n\n\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n\n\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n\n\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n\n\n  get hint() {\n    return this.s.collectionHint;\n  }\n\n  set hint(v) {\n    this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n  }\n\n  insertOne(doc, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n    // we support that option style here only\n\n\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  insertMany(docs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {\n      ordered: true\n    };\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  bulkWrite(operations, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: true\n    };\n\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  updateOne(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  replaceOne(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  updateMany(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  deleteOne(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  deleteMany(filter, options, callback) {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  rename(newName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, { ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }), callback);\n  }\n\n  drop(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n  }\n\n  findOne(filter, options, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n    const finalOptions = options !== null && options !== void 0 ? options : {};\n    return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n  }\n\n  find(filter, options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  options(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  isCapped(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  createIndex(indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  createIndexes(indexSpecs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  dropIndex(indexName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = (0, utils_1.resolveOptions)(this, options); // Run only against primary\n\n    options.readPreference = read_preference_1.ReadPreference.primary;\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);\n  }\n\n  dropIndexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n\n\n  listIndexes(options) {\n    return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  indexExists(indexes, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  indexInformation(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  estimatedDocumentCount(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  countDocuments(filter, options, callback) {\n    if (filter == null) {\n      filter = {}, options = {}, callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  } // Implementation\n\n\n  distinct(key, filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  indexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);\n  }\n\n  findOneAndDelete(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  findOneAndReplace(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  findOneAndUpdate(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n\n\n  aggregate() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n    }\n\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @remarks\n   * watch() accepts two generic arguments for distinct usecases:\n   * - The first is to override the schema that may be defined for this specific collection\n   * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n   * @example\n   * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n   * ```ts\n   * collection.watch<{ _id: number }>()\n   *   .on('change', change => console.log(change._id.toFixed(4)));\n   * ```\n   *\n   * @example\n   * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n   * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n   * No need start from scratch on the ChangeStreamInsertDocument type!\n   * By using an intersection we can save time and ensure defaults remain the same type!\n   * ```ts\n   * collection\n   *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n   *     { $addFields: { comment: 'big changes' } },\n   *     { $match: { operationType: 'insert' } }\n   *   ])\n   *   .on('change', change => {\n   *     change.comment.startsWith('big');\n   *     change.operationType === 'insert';\n   *     // No need to narrow in code because the generics did that for us!\n   *     expectType<Schema>(change.fullDocument);\n   *   });\n   * ```\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   * @typeParam TLocal - Type of the data being detected by the change stream\n   * @typeParam TChange - Type of the whole change stream document emitted\n   */\n\n\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  mapReduce(map, reduce, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.');\n    if ('function' === typeof options) callback = options, options = {}; // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n\n    if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n      throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n\n\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /**\n   * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n   *\n   * @throws MongoNotConnectedError\n   * @remarks\n   * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n   * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n   */\n\n\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Get the db scoped logger */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n  get logger() {\n    return this.s.db.s.logger;\n  }\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead.\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  insert(docs, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: false\n    };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  update(selector, update, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.updateMany(selector, update, options, callback);\n  }\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  remove(selector, options, callback) {\n    (0, utils_1.emitWarningOnce)('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.deleteMany(selector, options, callback);\n  }\n\n  count(filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n}\n\nexports.Collection = Collection;","map":{"version":3,"sources":["../src/collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collection = void 0;\nconst bson_1 = require(\"./bson\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\nconst list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nconst error_1 = require(\"./error\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_1 = require(\"./operations/count\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst delete_1 = require(\"./operations/delete\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst insert_1 = require(\"./operations/insert\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst map_reduce_1 = require(\"./operations/map_reduce\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst stats_1 = require(\"./operations/stats\");\nconst update_1 = require(\"./operations/update\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nclass Collection {\n    /**\n     * Create a new Collection instance\n     * @internal\n     */\n    constructor(db, name, options) {\n        var _a, _b;\n        (0, utils_1.checkCollectionName)(name);\n        // Internal state\n        this.s = {\n            db,\n            options,\n            namespace: new utils_1.MongoDBNamespace(db.databaseName, name),\n            pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n            readPreference: read_preference_1.ReadPreference.fromOptions(options),\n            bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n            readConcern: read_concern_1.ReadConcern.fromOptions(options),\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n        };\n    }\n    /**\n     * The name of the database this collection belongs to\n     */\n    get dbName() {\n        return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n    get collectionName() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n    get namespace() {\n        return this.s.namespace.toString();\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readConcern() {\n        if (this.s.readConcern == null) {\n            return this.s.db.readConcern;\n        }\n        return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readPreference() {\n        if (this.s.readPreference == null) {\n            return this.s.db.readPreference;\n        }\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get writeConcern() {\n        if (this.s.writeConcern == null) {\n            return this.s.db.writeConcern;\n        }\n        return this.s.writeConcern;\n    }\n    /** The current index hint for the collection */\n    get hint() {\n        return this.s.collectionHint;\n    }\n    set hint(v) {\n        this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n    }\n    insertOne(doc, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n        // we support that option style here only\n        if (options && Reflect.get(options, 'w')) {\n            options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n        }\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    insertMany(docs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : { ordered: true };\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    bulkWrite(operations, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: true };\n        if (!Array.isArray(operations)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n        }\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    updateOne(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    replaceOne(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    updateMany(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    deleteOne(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    deleteMany(filter, options, callback) {\n        if (filter == null) {\n            filter = {};\n            options = {};\n            callback = undefined;\n        }\n        else if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        else if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    rename(newName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        // Intentionally, we do not inherit options from parent for this operation.\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, {\n            ...options,\n            readPreference: read_preference_1.ReadPreference.PRIMARY\n        }), callback);\n    }\n    drop(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n    }\n    findOne(filter, options, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n        }\n        if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n        const finalOptions = options !== null && options !== void 0 ? options : {};\n        return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n    }\n    find(filter, options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n    }\n    options(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    isCapped(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    createIndex(indexSpec, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    createIndexes(indexSpecs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : {};\n        if (typeof options.maxTimeMS !== 'number')\n            delete options.maxTimeMS;\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    dropIndex(indexName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = (0, utils_1.resolveOptions)(this, options);\n        // Run only against primary\n        options.readPreference = read_preference_1.ReadPreference.primary;\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);\n    }\n    dropIndexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n    listIndexes(options) {\n        return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    indexExists(indexes, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    indexInformation(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    estimatedDocumentCount(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    countDocuments(filter, options, callback) {\n        if (filter == null) {\n            (filter = {}), (options = {}), (callback = undefined);\n        }\n        else if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 2) {\n                if (typeof options === 'function')\n                    (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    // Implementation\n    distinct(key, filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 3 && typeof options === 'function') {\n                (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    indexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    stats(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);\n    }\n    findOneAndDelete(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    findOneAndReplace(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    findOneAndUpdate(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n    aggregate(pipeline = [], options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n        }\n        if (!Array.isArray(pipeline)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct usecases:\n     * - The first is to override the schema that may be defined for this specific collection\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     * @example\n     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n     * ```ts\n     * collection.watch<{ _id: number }>()\n     *   .on('change', change => console.log(change._id.toFixed(4)));\n     * ```\n     *\n     * @example\n     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n     * No need start from scratch on the ChangeStreamInsertDocument type!\n     * By using an intersection we can save time and ensure defaults remain the same type!\n     * ```ts\n     * collection\n     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n     *     { $addFields: { comment: 'big changes' } },\n     *     { $match: { operationType: 'insert' } }\n     *   ])\n     *   .on('change', change => {\n     *     change.comment.startsWith('big');\n     *     change.operationType === 'insert';\n     *     // No need to narrow in code because the generics did that for us!\n     *     expectType<Schema>(change.fullDocument);\n     *   });\n     * ```\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TLocal - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    mapReduce(map, reduce, options, callback) {\n        (0, utils_1.emitWarningOnce)('collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.');\n        if ('function' === typeof options)\n            (callback = options), (options = {});\n        // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n        // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n        if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n            throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n        }\n        if ('function' === typeof map) {\n            map = map.toString();\n        }\n        if ('function' === typeof reduce) {\n            reduce = reduce.toString();\n        }\n        if ('function' === typeof options.finalize) {\n            options.finalize = options.finalize.toString();\n        }\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n    initializeUnorderedBulkOp(options) {\n        return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n    initializeOrderedBulkOp(options) {\n        return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /** Get the db scoped logger */\n    getLogger() {\n        return this.s.db.s.logger;\n    }\n    get logger() {\n        return this.s.db.s.logger;\n    }\n    /**\n     * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @deprecated Use insertOne, insertMany or bulkWrite instead.\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    insert(docs, options, callback) {\n        (0, utils_1.emitWarningOnce)('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: false };\n        docs = !Array.isArray(docs) ? [docs] : docs;\n        if (options.keepGoing === true) {\n            options.ordered = false;\n        }\n        return this.insertMany(docs, options, callback);\n    }\n    /**\n     * Updates documents.\n     *\n     * @deprecated use updateOne, updateMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    update(selector, update, options, callback) {\n        (0, utils_1.emitWarningOnce)('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.updateMany(selector, update, options, callback);\n    }\n    /**\n     * Remove documents.\n     *\n     * @deprecated use deleteOne, deleteMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    remove(selector, options, callback) {\n        (0, utils_1.emitWarningOnce)('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.deleteMany(selector, options, callback);\n    }\n    count(filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (typeof options === 'function')\n                (callback = options), (options = {});\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n}\nexports.Collection = Collection;\n//# sourceMappingURL=collection.js.map"]},"metadata":{},"sourceType":"script"}