{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nconst timers_1 = require(\"timers\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst commands_1 = require(\"./commands\");\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kHello = Symbol('hello');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    }); // hook the message stream up to the passed in stream\n\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get hello() {\n    return this[kHello];\n  } // the `connect` method stores the result of the handshake hello on the connection\n\n\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kHello] = response;\n  } // Set the whether the message stream is for a monitoring connection.\n\n\n  set isMonitoringConnection(value) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n\n  get isMonitoringConnection() {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n\n  onError(error) {\n    if (this.closed) {\n      return;\n    }\n\n    this[kStream].destroy(error);\n    this.closed = true;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(error);\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onClose() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    const message = `connection ${this.id} to ${this.address} closed`;\n\n    for (const op of this[kQueue].values()) {\n      op.cb(new error_1.MongoNetworkError(message));\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  onTimeout() {\n    if (this.closed) {\n      return;\n    }\n\n    this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n      this[kStream].destroy();\n      this.closed = true;\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n\n      for (const op of this[kQueue].values()) {\n        op.cb(new error_1.MongoNetworkTimeoutError(message, {\n          beforeHandshake\n        }));\n      }\n\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n\n    if (delayedTimeoutId != null) {\n      (0, timers_1.clearTimeout)(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    } // always emit the message, in case we are streaming\n\n\n    this.emit('message', message);\n    const operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    this[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      this[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      this[kStream].setTimeout(this.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, message.documents[0]);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  command(ns, cmd, options, callback) {\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"sources":["../../src/cmap/connection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nconst timers_1 = require(\"timers\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n    constructor(stream, options) {\n        var _a, _b;\n        super();\n        this.id = options.id;\n        this.address = streamIdentifier(stream, options);\n        this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n        this.monitorCommands = options.monitorCommands;\n        this.serverApi = options.serverApi;\n        this.closed = false;\n        this.destroyed = false;\n        this[kHello] = null;\n        this[kClusterTime] = null;\n        this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n        this[kGeneration] = options.generation;\n        this[kLastUseTime] = (0, utils_1.now)();\n        // setup parser stream and message handling\n        this[kQueue] = new Map();\n        this[kMessageStream] = new message_stream_1.MessageStream({\n            ...options,\n            maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n        });\n        this[kStream] = stream;\n        this[kDelayedTimeoutId] = null;\n        this[kMessageStream].on('message', message => this.onMessage(message));\n        this[kMessageStream].on('error', error => this.onError(error));\n        this[kStream].on('close', () => this.onClose());\n        this[kStream].on('timeout', () => this.onTimeout());\n        this[kStream].on('error', () => {\n            /* ignore errors, listen to `close` instead */\n        });\n        // hook the message stream up to the passed in stream\n        this[kStream].pipe(this[kMessageStream]);\n        this[kMessageStream].pipe(this[kStream]);\n    }\n    get description() {\n        return this[kDescription];\n    }\n    get hello() {\n        return this[kHello];\n    }\n    // the `connect` method stores the result of the handshake hello on the connection\n    set hello(response) {\n        this[kDescription].receiveResponse(response);\n        this[kDescription] = Object.freeze(this[kDescription]);\n        // TODO: remove this, and only use the `StreamDescription` in the future\n        this[kHello] = response;\n    }\n    // Set the whether the message stream is for a monitoring connection.\n    set isMonitoringConnection(value) {\n        this[kMessageStream].isMonitoringConnection = value;\n    }\n    get isMonitoringConnection() {\n        return this[kMessageStream].isMonitoringConnection;\n    }\n    get serviceId() {\n        var _a;\n        return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n    }\n    get loadBalanced() {\n        return this.description.loadBalanced;\n    }\n    get generation() {\n        return this[kGeneration] || 0;\n    }\n    set generation(generation) {\n        this[kGeneration] = generation;\n    }\n    get idleTime() {\n        return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n    }\n    get clusterTime() {\n        return this[kClusterTime];\n    }\n    get stream() {\n        return this[kStream];\n    }\n    markAvailable() {\n        this[kLastUseTime] = (0, utils_1.now)();\n    }\n    onError(error) {\n        if (this.closed) {\n            return;\n        }\n        this[kStream].destroy(error);\n        this.closed = true;\n        for (const op of this[kQueue].values()) {\n            op.cb(error);\n        }\n        this[kQueue].clear();\n        this.emit(Connection.CLOSE);\n    }\n    onClose() {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        const message = `connection ${this.id} to ${this.address} closed`;\n        for (const op of this[kQueue].values()) {\n            op.cb(new error_1.MongoNetworkError(message));\n        }\n        this[kQueue].clear();\n        this.emit(Connection.CLOSE);\n    }\n    onTimeout() {\n        if (this.closed) {\n            return;\n        }\n        this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n            this[kStream].destroy();\n            this.closed = true;\n            const message = `connection ${this.id} to ${this.address} timed out`;\n            const beforeHandshake = this.hello == null;\n            for (const op of this[kQueue].values()) {\n                op.cb(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));\n            }\n            this[kQueue].clear();\n            this.emit(Connection.CLOSE);\n        }, 1).unref(); // No need for this timer to hold the event loop open\n    }\n    onMessage(message) {\n        const delayedTimeoutId = this[kDelayedTimeoutId];\n        if (delayedTimeoutId != null) {\n            (0, timers_1.clearTimeout)(delayedTimeoutId);\n            this[kDelayedTimeoutId] = null;\n        }\n        // always emit the message, in case we are streaming\n        this.emit('message', message);\n        const operationDescription = this[kQueue].get(message.responseTo);\n        if (!operationDescription) {\n            return;\n        }\n        const callback = operationDescription.cb;\n        // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n        // track response, however the server currently synthetically produces remote requests\n        // making the `responseTo` change on each response\n        this[kQueue].delete(message.responseTo);\n        if ('moreToCome' in message && message.moreToCome) {\n            // requeue the callback for next synthetic request\n            this[kQueue].set(message.requestId, operationDescription);\n        }\n        else if (operationDescription.socketTimeoutOverride) {\n            this[kStream].setTimeout(this.socketTimeoutMS);\n        }\n        try {\n            // Pass in the entire description because it has BSON parsing options\n            message.parse(operationDescription);\n        }\n        catch (err) {\n            // If this error is generated by our own code, it will already have the correct class applied\n            // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n            // in either case, it should not be wrapped\n            callback(err);\n            return;\n        }\n        if (message.documents[0]) {\n            const document = message.documents[0];\n            const session = operationDescription.session;\n            if (session) {\n                (0, sessions_1.updateSessionFromResponse)(session, document);\n            }\n            if (document.$clusterTime) {\n                this[kClusterTime] = document.$clusterTime;\n                this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n            }\n            if (operationDescription.command) {\n                if (document.writeConcernError) {\n                    callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n                    return;\n                }\n                if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n            else {\n                // Pre 3.2 support\n                if (document.ok === 0 || document.$err || document.errmsg) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n        }\n        callback(undefined, message.documents[0]);\n    }\n    destroy(options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = { force: false };\n        }\n        this.removeAllListeners(Connection.PINNED);\n        this.removeAllListeners(Connection.UNPINNED);\n        options = Object.assign({ force: false }, options);\n        if (this[kStream] == null || this.destroyed) {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        if (options.force) {\n            this[kStream].destroy();\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        this[kStream].end(() => {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n        });\n    }\n    command(ns, cmd, options, callback) {\n        const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n        const shouldUseOpMsg = supportsOpMsg(this);\n        const session = options === null || options === void 0 ? void 0 : options.session;\n        let clusterTime = this.clusterTime;\n        let finalCmd = Object.assign({}, cmd);\n        if (this.serverApi) {\n            const { version, strict, deprecationErrors } = this.serverApi;\n            finalCmd.apiVersion = version;\n            if (strict != null)\n                finalCmd.apiStrict = strict;\n            if (deprecationErrors != null)\n                finalCmd.apiDeprecationErrors = deprecationErrors;\n        }\n        if (hasSessionSupport(this) && session) {\n            if (session.clusterTime &&\n                clusterTime &&\n                session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n                clusterTime = session.clusterTime;\n            }\n            const err = (0, sessions_1.applySession)(session, finalCmd, options);\n            if (err) {\n                return callback(err);\n            }\n        }\n        // if we have a known cluster time, gossip it\n        if (clusterTime) {\n            finalCmd.$clusterTime = clusterTime;\n        }\n        if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n            finalCmd = {\n                $query: finalCmd,\n                $readPreference: readPreference.toJSON()\n            };\n        }\n        const commandOptions = Object.assign({\n            command: true,\n            numberToSkip: 0,\n            numberToReturn: -1,\n            checkKeys: false,\n            // This value is not overridable\n            secondaryOk: readPreference.secondaryOk()\n        }, options);\n        const cmdNs = `${ns.db}.$cmd`;\n        const message = shouldUseOpMsg\n            ? new commands_1.Msg(cmdNs, finalCmd, commandOptions)\n            : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n        try {\n            write(this, message, commandOptions, callback);\n        }\n        catch (err) {\n            callback(err);\n        }\n    }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\nclass CryptoConnection extends Connection {\n    constructor(stream, options) {\n        super(stream, options);\n        this[kAutoEncrypter] = options.autoEncrypter;\n    }\n    /** @internal @override */\n    command(ns, cmd, options, callback) {\n        const autoEncrypter = this[kAutoEncrypter];\n        if (!autoEncrypter) {\n            return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n        }\n        const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n        if (serverWireVersion === 0) {\n            // This means the initial handshake hasn't happened yet\n            return super.command(ns, cmd, options, callback);\n        }\n        if (serverWireVersion < 8) {\n            callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n            return;\n        }\n        autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n            if (err || encrypted == null) {\n                callback(err, null);\n                return;\n            }\n            super.command(ns, encrypted, options, (err, response) => {\n                if (err || response == null) {\n                    callback(err, response);\n                    return;\n                }\n                autoEncrypter.decrypt(response, options, callback);\n            });\n        });\n    }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n    const description = conn.description;\n    return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n    const description = conn.description;\n    if (description == null) {\n        return false;\n    }\n    return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n    if (options.proxyHost) {\n        // If proxy options are specified, the properties of `stream` itself\n        // will not accurately reflect what endpoint this is connected to.\n        return options.hostAddress.toString();\n    }\n    if (typeof stream.address === 'function') {\n        return `${stream.remoteAddress}:${stream.remotePort}`;\n    }\n    return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n    options = options !== null && options !== void 0 ? options : {};\n    const operationDescription = {\n        requestId: command.requestId,\n        cb: callback,\n        session: options.session,\n        noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n        documentsReturnedIn: options.documentsReturnedIn,\n        command: !!options.command,\n        // for BSON parsing\n        promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n        promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n        promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n        bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n        enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n        raw: typeof options.raw === 'boolean' ? options.raw : false,\n        started: 0\n    };\n    if (conn[kDescription] && conn[kDescription].compressor) {\n        operationDescription.agreedCompressor = conn[kDescription].compressor;\n        if (conn[kDescription].zlibCompressionLevel) {\n            operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n        }\n    }\n    if (typeof options.socketTimeoutMS === 'number') {\n        operationDescription.socketTimeoutOverride = true;\n        conn[kStream].setTimeout(options.socketTimeoutMS);\n    }\n    // if command monitoring is enabled we need to modify the callback here\n    if (conn.monitorCommands) {\n        conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n        operationDescription.started = (0, utils_1.now)();\n        operationDescription.cb = (err, reply) => {\n            if (err) {\n                conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n            }\n            else {\n                if (reply && (reply.ok === 0 || reply.$err)) {\n                    conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n                }\n                else {\n                    conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n                }\n            }\n            if (typeof callback === 'function') {\n                callback(err, reply);\n            }\n        };\n    }\n    if (!operationDescription.noResponse) {\n        conn[kQueue].set(operationDescription.requestId, operationDescription);\n    }\n    try {\n        conn[kMessageStream].writeCommand(command, operationDescription);\n    }\n    catch (e) {\n        if (!operationDescription.noResponse) {\n            conn[kQueue].delete(operationDescription.requestId);\n            operationDescription.cb(e);\n            return;\n        }\n    }\n    if (operationDescription.noResponse) {\n        operationDescription.cb();\n    }\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"script"}