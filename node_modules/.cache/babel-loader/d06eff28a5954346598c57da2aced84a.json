{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\n\nconst error_1 = require(\"../../error\");\n\nconst read_preference_1 = require(\"../../read_preference\");\n\nconst common_1 = require(\"../../sdam/common\");\n\nconst topology_description_1 = require(\"../../sdam/topology_description\");\n\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one\n\n  if (options === null || options === void 0 ? void 0 : options.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n\n  return readPreference;\n}\n\nexports.getReadPreference = getReadPreference;\n\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\n\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer == null) {\n    return false;\n  }\n\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  } // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n\n\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n\n  return false;\n}\n\nexports.isSharded = isSharded;","map":{"version":3,"sources":["../../../src/cmap/wire_protocol/shared.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAIA,MAAA,sBAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AAQA,SAAgB,iBAAhB,CAAkC,GAAlC,EAAiD,OAAjD,EAA+E;EAC7E;EACA,IAAI,cAAc,GAAG,GAAG,CAAC,cAAJ,IAAsB,iBAAA,CAAA,cAAA,CAAe,OAA1D,CAF6E,CAG7E;;EACA,IAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,cAAb,EAA6B;IAC3B,cAAc,GAAG,OAAO,CAAC,cAAzB;EACD;;EAED,IAAI,OAAO,cAAP,KAA0B,QAA9B,EAAwC;IACtC,cAAc,GAAG,iBAAA,CAAA,cAAA,CAAe,UAAf,CAA0B,cAA1B,CAAjB;EACD;;EAED,IAAI,EAAE,cAAc,YAAY,iBAAA,CAAA,cAA5B,CAAJ,EAAiD;IAC/C,MAAM,IAAI,OAAA,CAAA,yBAAJ,CACJ,2DADI,CAAN;EAGD;;EAED,OAAO,cAAP;AACD;;AAnBD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAqBA,SAAgB,uBAAhB,CACE,YADF,EAEE,OAFF,EAEyB;EAEvB,MAAM,CAAC,MAAP,CAAc,YAAd,EAA4B;IAC1B,GAAG,EAAE,OAAO,OAAO,CAAC,GAAf,KAAuB,SAAvB,GAAmC,OAAO,CAAC,GAA3C,GAAiD,KAD5B;IAE1B,YAAY,EAAE,OAAO,OAAO,CAAC,YAAf,KAAgC,SAAhC,GAA4C,OAAO,CAAC,YAApD,GAAmE,IAFvD;IAG1B,aAAa,EAAE,OAAO,OAAO,CAAC,aAAf,KAAiC,SAAjC,GAA6C,OAAO,CAAC,aAArD,GAAqE,IAH1D;IAI1B,cAAc,EAAE,OAAO,OAAO,CAAC,cAAf,KAAkC,SAAlC,GAA8C,OAAO,CAAC,cAAtD,GAAuE,KAJ7D;IAK1B,UAAU,EAAE,OAAO,OAAO,CAAC,UAAf,KAA8B,SAA9B,GAA0C,OAAO,CAAC,UAAlD,GAA+D,KALjD;IAM1B,oBAAoB,EAClB,OAAO,OAAO,CAAC,oBAAf,KAAwC,SAAxC,GAAoD,OAAO,CAAC,oBAA5D,GAAmF;EAP3D,CAA5B;;EAUA,IAAI,OAAO,CAAC,OAAZ,EAAqB;IACnB,YAAY,CAAC,OAAb,GAAuB,OAAO,CAAC,OAA/B;EACD;;EAED,OAAO,YAAP;AACD;;AAnBD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAqBA,SAAgB,SAAhB,CAA0B,gBAA1B,EAA2E;EACzE,IAAI,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,OAAO,KAAP;EACD;;EAED,IAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,CAA6B,IAA7B,KAAsC,QAAA,CAAA,UAAA,CAAW,MAArF,EAA6F;IAC3F,OAAO,IAAP;EACD,CAPwE,CASzE;EACA;;;EACA,IAAI,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,WAAjB,YAAwC,sBAAA,CAAA,mBAA5E,EAAiG;IAC/F,MAAM,OAAO,GAAwB,KAAK,CAAC,IAAN,CAAW,gBAAgB,CAAC,WAAjB,CAA6B,OAA7B,CAAqC,MAArC,EAAX,CAArC;IACA,OAAO,OAAO,CAAC,IAAR,CAAc,MAAD,IAA+B,MAAM,CAAC,IAAP,KAAgB,QAAA,CAAA,UAAA,CAAW,MAAvE,CAAP;EACD;;EAED,OAAO,KAAP;AACD;;AAjBD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\nconst error_1 = require(\"../../error\");\nconst read_preference_1 = require(\"../../read_preference\");\nconst common_1 = require(\"../../sdam/common\");\nconst topology_description_1 = require(\"../../sdam/topology_description\");\nfunction getReadPreference(cmd, options) {\n    // Default to command version of the readPreference\n    let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary;\n    // If we have an option readPreference override the command one\n    if (options === null || options === void 0 ? void 0 : options.readPreference) {\n        readPreference = options.readPreference;\n    }\n    if (typeof readPreference === 'string') {\n        readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    }\n    if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n        throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n    }\n    return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction applyCommonQueryOptions(queryOptions, options) {\n    Object.assign(queryOptions, {\n        raw: typeof options.raw === 'boolean' ? options.raw : false,\n        promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n        promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n        promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n        bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n        enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n    });\n    if (options.session) {\n        queryOptions.session = options.session;\n    }\n    return queryOptions;\n}\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\nfunction isSharded(topologyOrServer) {\n    if (topologyOrServer == null) {\n        return false;\n    }\n    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n        return true;\n    }\n    // NOTE: This is incredibly inefficient, and should be removed once command construction\n    //       happens based on `Server` not `Topology`.\n    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n        const servers = Array.from(topologyOrServer.description.servers.values());\n        return servers.some((server) => server.type === common_1.ServerType.Mongos);\n    }\n    return false;\n}\nexports.isSharded = isSharded;\n//# sourceMappingURL=shared.js.map"]},"metadata":{},"sourceType":"script"}