{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst get_more_1 = require(\"../operations/get_more\");\n\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n/** @internal */\n\n\nconst kId = Symbol('id');\n/** @internal */\n\nconst kDocuments = Symbol('documents');\n/** @internal */\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kNamespace = Symbol('namespace');\n/** @internal */\n\nconst kClient = Symbol('client');\n/** @internal */\n\nconst kSession = Symbol('session');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/** @internal */\n\nconst kTransform = Symbol('transform');\n/** @internal */\n\nconst kInitialized = Symbol('initialized');\n/** @internal */\n\nconst kClosed = Symbol('closed');\n/** @internal */\n\nconst kKilled = Symbol('killed');\n/** @internal */\n\nconst kInit = Symbol('kInit');\n/** @public */\n\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n\n  get id() {\n    return this[kId];\n  }\n  /** @internal */\n\n\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n\n\n  get server() {\n    return this[kServer];\n  }\n\n  get namespace() {\n    return this[kNamespace];\n  }\n\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n\n\n  get session() {\n    return this[kSession];\n  }\n\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n\n\n  get cursorOptions() {\n    return this[kOptions];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get killed() {\n    return this[kKilled];\n  }\n\n  get loadBalanced() {\n    var _a;\n\n    return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);\n  }\n  /** Returns current buffered documents length */\n\n\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n\n\n  readBufferedDocuments(number) {\n    return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: () => this.next().then(value => value != null ? {\n        value,\n        done: false\n      } : {\n        value: undefined,\n        done: true\n      })\n    };\n  }\n\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n\n      }));\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  hasNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(undefined, false);\n      }\n\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n\n      next(this, true, (err, doc) => {\n        if (err) return done(err);\n\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n\n        done(undefined, false);\n      });\n    });\n  }\n\n  next(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, true, done);\n    });\n  }\n\n  tryNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, false, done);\n    });\n  }\n\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n\n    return (0, utils_1.maybePromise)(callback, done => {\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        next(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result; // NOTE: no need to transform because `next` will do this automatically\n\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n\n          if (result === false) return done(); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n\n            if (result === false) return done();\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return (0, utils_1.maybePromise)(callback, done => cleanupCursor(this, {\n      needsToEmitClosed\n    }, done));\n  }\n\n  toArray(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      const docs = [];\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs); // NOTE: no need to transform because `next` will do this automatically\n\n          docs.push(doc); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = transform ? this[kDocuments].splice(0, this[kDocuments].length).map(transform) : this[kDocuments].splice(0, this[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n\n\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n\n\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n\n\n  maxTimeMS(value) {\n    assertUninitialized(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n\n\n  batchSize(value) {\n    assertUninitialized(this);\n\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n\n\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n\n    if (cursorId == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n      return;\n    }\n\n    if (server == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n      return;\n    }\n\n    const getMoreOperation = new get_more_1.GetMoreOperation(cursorNs, cursorId, server, { ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n\n\n  [kInit](callback) {\n    this._initialize(this[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n\n        if (response.cursor) {\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n\n          this[kDocuments] = response.cursor.firstBatch;\n        } // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n\n\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n\n          this[kDocuments] = [state.response];\n        }\n      } // the cursor is now initialized, even if an error occurred or it is dead\n\n\n      this[kInitialized] = true;\n\n      if (err || cursorIsDead(this)) {\n        return cleanupCursor(this, {\n          error: err\n        }, () => callback(err, nextDocument(this)));\n      }\n\n      callback();\n    });\n  }\n\n}\n\nexports.AbstractCursor = AbstractCursor;\n/** @event */\n\nAbstractCursor.CLOSE = 'close';\n\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n\n  const doc = cursor[kDocuments].shift();\n\n  if (doc) {\n    const transform = cursor[kTransform];\n\n    if (transform) {\n      return transform(doc);\n    }\n\n    return doc;\n  }\n\n  return null;\n}\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\n\n\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit]((err, value) => {\n      if (err) return callback(err);\n\n      if (value) {\n        return callback(undefined, value);\n      }\n\n      return next(cursor, blocking, callback);\n    });\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  } // otherwise need to call getMore\n\n\n  const batchSize = cursor[kOptions].batchSize || 1000;\n\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error: err\n      }, () => callback(err, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nexports.next = next;\n\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n  return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session\n  }), completeCleanup);\n}\n/** @internal */\n\n\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\n\nexports.assertUninitialized = assertUninitialized;\n\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n\n      this._readNext();\n    }\n  }\n\n  _destroy(error, callback) {\n    this._cursor.close(err => process.nextTick(callback, err || error));\n  }\n\n  _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n\n          return this.push(null);\n        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n\n\n        if (err.message.match(/interrupted/)) {\n          return this.push(null);\n        }\n\n        return this.destroy(err);\n      }\n\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n\n        this._readInProgress = false;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/cursor/abstract_cursor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'exhaust',\n    'partial'\n];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n    /** @internal */\n    constructor(client, namespace, options = {}) {\n        super();\n        if (!client.s.isMongoClient) {\n            throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n        }\n        this[kClient] = client;\n        this[kNamespace] = namespace;\n        this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n        this[kInitialized] = false;\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kOptions] = {\n            readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference\n                ? options.readPreference\n                : read_preference_1.ReadPreference.primary,\n            ...(0, bson_1.pluckBSONSerializeOptions)(options)\n        };\n        const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n        if (readConcern) {\n            this[kOptions].readConcern = readConcern;\n        }\n        if (typeof options.batchSize === 'number') {\n            this[kOptions].batchSize = options.batchSize;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (options.comment !== undefined) {\n            this[kOptions].comment = options.comment;\n        }\n        if (typeof options.maxTimeMS === 'number') {\n            this[kOptions].maxTimeMS = options.maxTimeMS;\n        }\n        if (options.session instanceof sessions_1.ClientSession) {\n            this[kSession] = options.session;\n        }\n        else {\n            this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    /** @internal */\n    get client() {\n        return this[kClient];\n    }\n    /** @internal */\n    get server() {\n        return this[kServer];\n    }\n    get namespace() {\n        return this[kNamespace];\n    }\n    get readPreference() {\n        return this[kOptions].readPreference;\n    }\n    get readConcern() {\n        return this[kOptions].readConcern;\n    }\n    /** @internal */\n    get session() {\n        return this[kSession];\n    }\n    set session(clientSession) {\n        this[kSession] = clientSession;\n    }\n    /** @internal */\n    get cursorOptions() {\n        return this[kOptions];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get killed() {\n        return this[kKilled];\n    }\n    get loadBalanced() {\n        var _a;\n        return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);\n    }\n    /** Returns current buffered documents length */\n    bufferedCount() {\n        return this[kDocuments].length;\n    }\n    /** Returns current buffered documents */\n    readBufferedDocuments(number) {\n        return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: () => this.next().then(value => value != null ? { value, done: false } : { value: undefined, done: true })\n        };\n    }\n    stream(options) {\n        if (options === null || options === void 0 ? void 0 : options.transform) {\n            const transform = options.transform;\n            const readable = new ReadableCursorStream(this);\n            return readable.pipe(new stream_1.Transform({\n                objectMode: true,\n                highWaterMark: 1,\n                transform(chunk, _, callback) {\n                    try {\n                        const transformed = transform(chunk);\n                        callback(undefined, transformed);\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                }\n            }));\n        }\n        return new ReadableCursorStream(this);\n    }\n    hasNext(callback) {\n        return (0, utils_1.maybePromise)(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(undefined, false);\n            }\n            if (this[kDocuments].length) {\n                return done(undefined, true);\n            }\n            next(this, true, (err, doc) => {\n                if (err)\n                    return done(err);\n                if (doc) {\n                    this[kDocuments].unshift(doc);\n                    done(undefined, true);\n                    return;\n                }\n                done(undefined, false);\n            });\n        });\n    }\n    next(callback) {\n        return (0, utils_1.maybePromise)(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(new error_1.MongoCursorExhaustedError());\n            }\n            next(this, true, done);\n        });\n    }\n    tryNext(callback) {\n        return (0, utils_1.maybePromise)(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(new error_1.MongoCursorExhaustedError());\n            }\n            next(this, false, done);\n        });\n    }\n    forEach(iterator, callback) {\n        if (typeof iterator !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n        }\n        return (0, utils_1.maybePromise)(callback, done => {\n            const transform = this[kTransform];\n            const fetchDocs = () => {\n                next(this, true, (err, doc) => {\n                    if (err || doc == null)\n                        return done(err);\n                    let result;\n                    // NOTE: no need to transform because `next` will do this automatically\n                    try {\n                        result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n                    }\n                    catch (error) {\n                        return done(error);\n                    }\n                    if (result === false)\n                        return done();\n                    // these do need to be transformed since they are copying the rest of the batch\n                    const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n                    for (let i = 0; i < internalDocs.length; ++i) {\n                        try {\n                            result = iterator((transform ? transform(internalDocs[i]) : internalDocs[i]) // TODO(NODE-3283): Improve transform typing\n                            );\n                        }\n                        catch (error) {\n                            return done(error);\n                        }\n                        if (result === false)\n                            return done();\n                    }\n                    fetchDocs();\n                });\n            };\n            fetchDocs();\n        });\n    }\n    close(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        const needsToEmitClosed = !this[kClosed];\n        this[kClosed] = true;\n        return (0, utils_1.maybePromise)(callback, done => cleanupCursor(this, { needsToEmitClosed }, done));\n    }\n    toArray(callback) {\n        return (0, utils_1.maybePromise)(callback, done => {\n            const docs = [];\n            const transform = this[kTransform];\n            const fetchDocs = () => {\n                // NOTE: if we add a `nextBatch` then we should use it here\n                next(this, true, (err, doc) => {\n                    if (err)\n                        return done(err);\n                    if (doc == null)\n                        return done(undefined, docs);\n                    // NOTE: no need to transform because `next` will do this automatically\n                    docs.push(doc);\n                    // these do need to be transformed since they are copying the rest of the batch\n                    const internalDocs = (transform\n                        ? this[kDocuments].splice(0, this[kDocuments].length).map(transform)\n                        : this[kDocuments].splice(0, this[kDocuments].length)); // TODO(NODE-3283): Improve transform typing\n                    if (internalDocs) {\n                        docs.push(...internalDocs);\n                    }\n                    fetchDocs();\n                });\n            };\n            fetchDocs();\n        });\n    }\n    /**\n     * Add a cursor flag to the cursor\n     *\n     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n     * @param value - The flag boolean value.\n     */\n    addCursorFlag(flag, value) {\n        assertUninitialized(this);\n        if (!exports.CURSOR_FLAGS.includes(flag)) {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n        }\n        if (typeof value !== 'boolean') {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n        }\n        this[kOptions][flag] = value;\n        return this;\n    }\n    /**\n     * Map all documents using the provided function\n     * If there is a transform set on the cursor, that will be called first and the result passed to\n     * this function's transform.\n     *\n     * @remarks\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling map,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: FindCursor<Document> = coll.find();\n     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n     * ```\n     * @param transform - The mapping transformation method.\n     */\n    map(transform) {\n        assertUninitialized(this);\n        const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n        if (oldTransform) {\n            this[kTransform] = doc => {\n                return transform(oldTransform(doc));\n            };\n        }\n        else {\n            this[kTransform] = transform;\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadPreference(readPreference) {\n        assertUninitialized(this);\n        if (readPreference instanceof read_preference_1.ReadPreference) {\n            this[kOptions].readPreference = readPreference;\n        }\n        else if (typeof readPreference === 'string') {\n            this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadConcern(readConcern) {\n        assertUninitialized(this);\n        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });\n        if (resolvedReadConcern) {\n            this[kOptions].readConcern = resolvedReadConcern;\n        }\n        return this;\n    }\n    /**\n     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n     *\n     * @param value - Number of milliseconds to wait before aborting the query.\n     */\n    maxTimeMS(value) {\n        assertUninitialized(this);\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n        }\n        this[kOptions].maxTimeMS = value;\n        return this;\n    }\n    /**\n     * Set the batch size for the cursor.\n     *\n     * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n     */\n    batchSize(value) {\n        assertUninitialized(this);\n        if (this[kOptions].tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n        }\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n        }\n        this[kOptions].batchSize = value;\n        return this;\n    }\n    /**\n     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n     * if the resultant data has already been retrieved by this cursor.\n     */\n    rewind() {\n        if (!this[kInitialized]) {\n            return;\n        }\n        this[kId] = undefined;\n        this[kDocuments] = [];\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kInitialized] = false;\n        const session = this[kSession];\n        if (session) {\n            // We only want to end this session if we created it, and it hasn't ended yet\n            if (session.explicit === false) {\n                if (!session.hasEnded) {\n                    session.endSession().catch(() => null);\n                }\n                this[kSession] = this.client.startSession({ owner: this, explicit: false });\n            }\n        }\n    }\n    /** @internal */\n    _getMore(batchSize, callback) {\n        const cursorId = this[kId];\n        const cursorNs = this[kNamespace];\n        const server = this[kServer];\n        if (cursorId == null) {\n            callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n            return;\n        }\n        if (server == null) {\n            callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n            return;\n        }\n        const getMoreOperation = new get_more_1.GetMoreOperation(cursorNs, cursorId, server, {\n            ...this[kOptions],\n            session: this[kSession],\n            batchSize\n        });\n        (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n    }\n    /**\n     * @internal\n     *\n     * This function is exposed for the unified test runner's createChangeStream\n     * operation.  We cannot refactor to use the abstract _initialize method without\n     * a significant refactor.\n     */\n    [kInit](callback) {\n        this._initialize(this[kSession], (err, state) => {\n            if (state) {\n                const response = state.response;\n                this[kServer] = state.server;\n                if (response.cursor) {\n                    this[kId] =\n                        typeof response.cursor.id === 'number'\n                            ? bson_1.Long.fromNumber(response.cursor.id)\n                            : response.cursor.id;\n                    if (response.cursor.ns) {\n                        this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n                    }\n                    this[kDocuments] = response.cursor.firstBatch;\n                }\n                // When server responses return without a cursor document, we close this cursor\n                // and return the raw server response. This is often the case for explain commands\n                // for example\n                if (this[kId] == null) {\n                    this[kId] = bson_1.Long.ZERO;\n                    // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n                    this[kDocuments] = [state.response];\n                }\n            }\n            // the cursor is now initialized, even if an error occurred or it is dead\n            this[kInitialized] = true;\n            if (err || cursorIsDead(this)) {\n                return cleanupCursor(this, { error: err }, () => callback(err, nextDocument(this)));\n            }\n            callback();\n        });\n    }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n    if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n        return null;\n    }\n    const doc = cursor[kDocuments].shift();\n    if (doc) {\n        const transform = cursor[kTransform];\n        if (transform) {\n            return transform(doc);\n        }\n        return doc;\n    }\n    return null;\n}\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nfunction next(cursor, blocking, callback) {\n    const cursorId = cursor[kId];\n    if (cursor.closed) {\n        return callback(undefined, null);\n    }\n    if (cursor[kDocuments] && cursor[kDocuments].length) {\n        callback(undefined, nextDocument(cursor));\n        return;\n    }\n    if (cursorId == null) {\n        // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n        cursor[kInit]((err, value) => {\n            if (err)\n                return callback(err);\n            if (value) {\n                return callback(undefined, value);\n            }\n            return next(cursor, blocking, callback);\n        });\n        return;\n    }\n    if (cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n    }\n    // otherwise need to call getMore\n    const batchSize = cursor[kOptions].batchSize || 1000;\n    cursor._getMore(batchSize, (err, response) => {\n        if (response) {\n            const cursorId = typeof response.cursor.id === 'number'\n                ? bson_1.Long.fromNumber(response.cursor.id)\n                : response.cursor.id;\n            cursor[kDocuments] = response.cursor.nextBatch;\n            cursor[kId] = cursorId;\n        }\n        if (err || cursorIsDead(cursor)) {\n            return cleanupCursor(cursor, { error: err }, () => callback(err, nextDocument(cursor)));\n        }\n        if (cursor[kDocuments].length === 0 && blocking === false) {\n            return callback(undefined, null);\n        }\n        next(cursor, blocking, callback);\n    });\n}\nexports.next = next;\nfunction cursorIsDead(cursor) {\n    const cursorId = cursor[kId];\n    return !!cursorId && cursorId.isZero();\n}\nfunction cleanupCursor(cursor, options, callback) {\n    var _a;\n    const cursorId = cursor[kId];\n    const cursorNs = cursor[kNamespace];\n    const server = cursor[kServer];\n    const session = cursor[kSession];\n    const error = options === null || options === void 0 ? void 0 : options.error;\n    const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n    if (error) {\n        if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n            return completeCleanup();\n        }\n    }\n    if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n        if (needsToEmitClosed) {\n            cursor[kClosed] = true;\n            cursor[kId] = bson_1.Long.ZERO;\n            cursor.emit(AbstractCursor.CLOSE);\n        }\n        if (session) {\n            if (session.owner === cursor) {\n                return session.endSession({ error }, callback);\n            }\n            if (!session.inTransaction()) {\n                (0, sessions_1.maybeClearPinnedConnection)(session, { error });\n            }\n        }\n        return callback();\n    }\n    function completeCleanup() {\n        if (session) {\n            if (session.owner === cursor) {\n                return session.endSession({ error }, () => {\n                    cursor.emit(AbstractCursor.CLOSE);\n                    callback();\n                });\n            }\n            if (!session.inTransaction()) {\n                (0, sessions_1.maybeClearPinnedConnection)(session, { error });\n            }\n        }\n        cursor.emit(AbstractCursor.CLOSE);\n        return callback();\n    }\n    cursor[kKilled] = true;\n    return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, { session }), completeCleanup);\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n    if (cursor[kInitialized]) {\n        throw new error_1.MongoCursorInUseError();\n    }\n}\nexports.assertUninitialized = assertUninitialized;\nclass ReadableCursorStream extends stream_1.Readable {\n    constructor(cursor) {\n        super({\n            objectMode: true,\n            autoDestroy: false,\n            highWaterMark: 1\n        });\n        this._readInProgress = false;\n        this._cursor = cursor;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _read(size) {\n        if (!this._readInProgress) {\n            this._readInProgress = true;\n            this._readNext();\n        }\n    }\n    _destroy(error, callback) {\n        this._cursor.close(err => process.nextTick(callback, err || error));\n    }\n    _readNext() {\n        next(this._cursor, true, (err, result) => {\n            if (err) {\n                // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n                //       desired behavior is that a stream ends cleanly when a user explicitly closes\n                //       a client during iteration. Alternatively, we could do the \"right\" thing and\n                //       propagate the error message by removing this special case.\n                if (err.message.match(/server is closed/)) {\n                    this._cursor.close().catch(() => null);\n                    return this.push(null);\n                }\n                // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n                //       to be \"operation interrupted\", where a cursor has been closed but there is an\n                //       active getMore in-flight. This used to check if the cursor was killed but once\n                //       that changed to happen in cleanup legitimate errors would not destroy the\n                //       stream. There are change streams test specifically test these cases.\n                if (err.message.match(/interrupted/)) {\n                    return this.push(null);\n                }\n                return this.destroy(err);\n            }\n            if (result == null) {\n                this.push(null);\n            }\n            else if (this.destroyed) {\n                this._cursor.close().catch(() => null);\n            }\n            else {\n                if (this.push(result)) {\n                    return this._readNext();\n                }\n                this._readInProgress = false;\n            }\n        });\n    }\n}\n//# sourceMappingURL=abstract_cursor.js.map"]},"metadata":{},"sourceType":"script"}