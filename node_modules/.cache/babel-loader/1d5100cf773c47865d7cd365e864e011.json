{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RTTPinger = exports.Monitor = void 0;\n\nconst timers_1 = require(\"timers\");\n\nconst bson_1 = require(\"../bson\");\n\nconst connect_1 = require(\"../cmap/connect\");\n\nconst connection_1 = require(\"../cmap/connection\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst utils_1 = require(\"../utils\");\n\nconst common_1 = require(\"./common\");\n\nconst events_1 = require(\"./events\");\n\nconst server_1 = require(\"./server\");\n/** @internal */\n\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\n\nconst kConnection = Symbol('connection');\n/** @internal */\n\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\n\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\n\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\n\n\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  constructor(server, options) {\n    var _a, _b, _c;\n\n    super();\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,\n      heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,\n      minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500\n    });\n    const cancellationToken = this[kCancellationToken]; // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      generation: server.s.pool.generation,\n      connectionType: connection_1.Connection,\n      cancellationToken,\n      hostAddress: server.description.hostAddress\n    }, options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  get connection() {\n    return this[kConnection];\n  }\n\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    var _a;\n\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n  }\n\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this); // restart monitor\n\n    stateTransition(this, STATE_IDLE); // restart monitoring\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this); // close monitor\n\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n\n}\n\nexports.Monitor = Monitor;\n\nfunction resetMonitorState(monitor) {\n  var _a, _b, _c;\n\n  (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();\n  monitor[kMonitorId] = undefined;\n  (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();\n  monitor[kRTTPinger] = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({\n    force: true\n  });\n  monitor[kConnection] = undefined;\n}\n\nfunction checkServer(monitor, callback) {\n  let start = (0, utils_1.now)();\n  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    var _a;\n\n    (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    monitor[kConnection] = undefined;\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  const connection = monitor[kConnection];\n\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n\n    connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, (err, hello) => {\n      var _a;\n\n      if (err) {\n        return failureHandler(err);\n      }\n\n      if (!('isWritablePrimary' in hello)) {\n        // Provide hello-style response document.\n        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && hello.topologyVersion) {\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n        start = (0, utils_1.now)();\n      } else {\n        (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();\n        monitor[kRTTPinger] = undefined;\n        callback(undefined, hello);\n      }\n    });\n    return;\n  } // connecting does an implicit `hello`\n\n\n  (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof error_1.MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    if (conn) {\n      // Tell the connection that we are using the streaming protocol so that the\n      // connection's message stream will only read the last hello on the buffer.\n      conn.isMonitoringConnection = true;\n\n      if (isInCloseState(monitor)) {\n        conn.destroy({\n          force: true\n        });\n        return;\n      }\n\n      monitor[kConnection] = conn;\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));\n      callback(undefined, conn.hello);\n    }\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, hello) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (hello && hello.topologyVersion) {\n        (0, timers_1.setTimeout)(() => {\n          var _a;\n\n          if (!isInCloseState(monitor)) {\n            (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\n\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    var _a;\n\n    this.closed = true;\n    (0, timers_1.clearTimeout)(this[kMonitorId]);\n    (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    this[kConnection] = undefined;\n  }\n\n}\n\nexports.RTTPinger = RTTPinger;\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = (0, utils_1.now)();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn === null || conn === void 0 ? void 0 : conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n    rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n\n  const connection = rttPinger[kConnection];\n\n  if (connection == null) {\n    (0, connect_1.connect)(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  connection.command((0, utils_1.ns)('admin.$cmd'), {\n    [constants_1.LEGACY_HELLO_COMMAND]: 1\n  }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}","map":{"version":3,"sources":["../../src/sdam/monitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RTTPinger = exports.Monitor = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst connect_1 = require(\"../cmap/connect\");\nconst connection_1 = require(\"../cmap/connection\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kConnection = Symbol('connection');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n    constructor(server, options) {\n        var _a, _b, _c;\n        super();\n        this[kServer] = server;\n        this[kConnection] = undefined;\n        this[kCancellationToken] = new mongo_types_1.CancellationToken();\n        this[kCancellationToken].setMaxListeners(Infinity);\n        this[kMonitorId] = undefined;\n        this.s = {\n            state: common_1.STATE_CLOSED\n        };\n        this.address = server.description.address;\n        this.options = Object.freeze({\n            connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,\n            heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,\n            minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500\n        });\n        const cancellationToken = this[kCancellationToken];\n        // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n        const connectOptions = Object.assign({\n            id: '<monitor>',\n            generation: server.s.pool.generation,\n            connectionType: connection_1.Connection,\n            cancellationToken,\n            hostAddress: server.description.hostAddress\n        }, options, \n        // force BSON serialization options\n        {\n            raw: false,\n            promoteLongs: true,\n            promoteValues: true,\n            promoteBuffers: true\n        });\n        // ensure no authentication is used for monitoring\n        delete connectOptions.credentials;\n        if (connectOptions.autoEncrypter) {\n            delete connectOptions.autoEncrypter;\n        }\n        this.connectOptions = Object.freeze(connectOptions);\n    }\n    get connection() {\n        return this[kConnection];\n    }\n    connect() {\n        if (this.s.state !== common_1.STATE_CLOSED) {\n            return;\n        }\n        // start\n        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n        this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n            interval: heartbeatFrequencyMS,\n            minInterval: minHeartbeatFrequencyMS,\n            immediate: true\n        });\n    }\n    requestCheck() {\n        var _a;\n        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n            return;\n        }\n        (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n    }\n    reset() {\n        const topologyVersion = this[kServer].description.topologyVersion;\n        if (isInCloseState(this) || topologyVersion == null) {\n            return;\n        }\n        stateTransition(this, common_1.STATE_CLOSING);\n        resetMonitorState(this);\n        // restart monitor\n        stateTransition(this, STATE_IDLE);\n        // restart monitoring\n        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n        this[kMonitorId] = (0, utils_1.makeInterruptibleAsyncInterval)(monitorServer(this), {\n            interval: heartbeatFrequencyMS,\n            minInterval: minHeartbeatFrequencyMS\n        });\n    }\n    close() {\n        if (isInCloseState(this)) {\n            return;\n        }\n        stateTransition(this, common_1.STATE_CLOSING);\n        resetMonitorState(this);\n        // close monitor\n        this.emit('close');\n        stateTransition(this, common_1.STATE_CLOSED);\n    }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n    var _a, _b, _c;\n    (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();\n    monitor[kMonitorId] = undefined;\n    (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();\n    monitor[kRTTPinger] = undefined;\n    monitor[kCancellationToken].emit('cancel');\n    (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({ force: true });\n    monitor[kConnection] = undefined;\n}\nfunction checkServer(monitor, callback) {\n    let start = (0, utils_1.now)();\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n    function failureHandler(err) {\n        var _a;\n        (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({ force: true });\n        monitor[kConnection] = undefined;\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));\n        monitor.emit('resetServer', err);\n        monitor.emit('resetConnectionPool');\n        callback(err);\n    }\n    const connection = monitor[kConnection];\n    if (connection && !connection.closed) {\n        const { serverApi, helloOk } = connection;\n        const connectTimeoutMS = monitor.options.connectTimeoutMS;\n        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n        const topologyVersion = monitor[kServer].description.topologyVersion;\n        const isAwaitable = topologyVersion != null;\n        const cmd = {\n            [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n            ...(isAwaitable && topologyVersion\n                ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n                : {})\n        };\n        const options = isAwaitable\n            ? {\n                socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n                exhaustAllowed: true\n            }\n            : { socketTimeoutMS: connectTimeoutMS };\n        if (isAwaitable && monitor[kRTTPinger] == null) {\n            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({ heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS }, monitor.connectOptions));\n        }\n        connection.command((0, utils_1.ns)('admin.$cmd'), cmd, options, (err, hello) => {\n            var _a;\n            if (err) {\n                return failureHandler(err);\n            }\n            if (!('isWritablePrimary' in hello)) {\n                // Provide hello-style response document.\n                hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n            }\n            const rttPinger = monitor[kRTTPinger];\n            const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);\n            monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello));\n            // if we are using the streaming protocol then we immediately issue another `started`\n            // event, otherwise the \"check\" is complete and return to the main monitor loop\n            if (isAwaitable && hello.topologyVersion) {\n                monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n                start = (0, utils_1.now)();\n            }\n            else {\n                (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();\n                monitor[kRTTPinger] = undefined;\n                callback(undefined, hello);\n            }\n        });\n        return;\n    }\n    // connecting does an implicit `hello`\n    (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {\n        if (err) {\n            monitor[kConnection] = undefined;\n            // we already reset the connection pool on network errors in all cases\n            if (!(err instanceof error_1.MongoNetworkError)) {\n                monitor.emit('resetConnectionPool');\n            }\n            failureHandler(err);\n            return;\n        }\n        if (conn) {\n            // Tell the connection that we are using the streaming protocol so that the\n            // connection's message stream will only read the last hello on the buffer.\n            conn.isMonitoringConnection = true;\n            if (isInCloseState(monitor)) {\n                conn.destroy({ force: true });\n                return;\n            }\n            monitor[kConnection] = conn;\n            monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));\n            callback(undefined, conn.hello);\n        }\n    });\n}\nfunction monitorServer(monitor) {\n    return (callback) => {\n        stateTransition(monitor, STATE_MONITORING);\n        function done() {\n            if (!isInCloseState(monitor)) {\n                stateTransition(monitor, STATE_IDLE);\n            }\n            callback();\n        }\n        checkServer(monitor, (err, hello) => {\n            if (err) {\n                // otherwise an error occurred on initial discovery, also bail\n                if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n                    monitor.emit('resetServer', err);\n                    return done();\n                }\n            }\n            // if the check indicates streaming is supported, immediately reschedule monitoring\n            if (hello && hello.topologyVersion) {\n                (0, timers_1.setTimeout)(() => {\n                    var _a;\n                    if (!isInCloseState(monitor)) {\n                        (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n                    }\n                }, 0);\n            }\n            done();\n        });\n    };\n}\nfunction makeTopologyVersion(tv) {\n    return {\n        processId: tv.processId,\n        // tests mock counter as just number, but in a real situation counter should always be a Long\n        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n    };\n}\n/** @internal */\nclass RTTPinger {\n    constructor(cancellationToken, options) {\n        this[kConnection] = undefined;\n        this[kCancellationToken] = cancellationToken;\n        this[kRoundTripTime] = 0;\n        this.closed = false;\n        const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n        this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n    }\n    get roundTripTime() {\n        return this[kRoundTripTime];\n    }\n    close() {\n        var _a;\n        this.closed = true;\n        (0, timers_1.clearTimeout)(this[kMonitorId]);\n        (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({ force: true });\n        this[kConnection] = undefined;\n    }\n}\nexports.RTTPinger = RTTPinger;\nfunction measureRoundTripTime(rttPinger, options) {\n    const start = (0, utils_1.now)();\n    options.cancellationToken = rttPinger[kCancellationToken];\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    if (rttPinger.closed) {\n        return;\n    }\n    function measureAndReschedule(conn) {\n        if (rttPinger.closed) {\n            conn === null || conn === void 0 ? void 0 : conn.destroy({ force: true });\n            return;\n        }\n        if (rttPinger[kConnection] == null) {\n            rttPinger[kConnection] = conn;\n        }\n        rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);\n        rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n    }\n    const connection = rttPinger[kConnection];\n    if (connection == null) {\n        (0, connect_1.connect)(options, (err, conn) => {\n            if (err) {\n                rttPinger[kConnection] = undefined;\n                rttPinger[kRoundTripTime] = 0;\n                return;\n            }\n            measureAndReschedule(conn);\n        });\n        return;\n    }\n    connection.command((0, utils_1.ns)('admin.$cmd'), { [constants_1.LEGACY_HELLO_COMMAND]: 1 }, undefined, err => {\n        if (err) {\n            rttPinger[kConnection] = undefined;\n            rttPinger[kRoundTripTime] = 0;\n            return;\n        }\n        measureAndReschedule();\n    });\n}\n//# sourceMappingURL=monitor.js.map"]},"metadata":{},"sourceType":"script"}