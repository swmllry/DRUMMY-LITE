{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction makeIndexSpec(indexSpec, options) {\n  const indexParameters = (0, utils_1.parseIndexOptions)(indexSpec); // Generate the index name\n\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const finalIndexSpec = {\n    name,\n    key: indexParameters.fieldHash\n  }; // merge valid index options into the index spec\n\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec;\n}\n/** @internal */\n\n\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` + 'does not support collation'));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n\n}\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n\n}\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n\n}\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n\n}\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n\n}\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    const command = {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }; // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n    if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\n\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err); // Let's check for the index names\n\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      } // All keys found return true\n\n\n      return callback(undefined, true);\n    });\n  }\n\n}\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["../../src/operations/indexes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\nconst VALID_INDEX_OPTIONS = new Set([\n    'background',\n    'unique',\n    'name',\n    'partialFilterExpression',\n    'sparse',\n    'hidden',\n    'expireAfterSeconds',\n    'storageEngine',\n    'collation',\n    'version',\n    // text indexes\n    'weights',\n    'default_language',\n    'language_override',\n    'textIndexVersion',\n    // 2d-sphere indexes\n    '2dsphereIndexVersion',\n    // 2d indexes\n    'bits',\n    'min',\n    'max',\n    // geoHaystack Indexes\n    'bucketSize',\n    // wildcard indexes\n    'wildcardProjection'\n]);\nfunction makeIndexSpec(indexSpec, options) {\n    const indexParameters = (0, utils_1.parseIndexOptions)(indexSpec);\n    // Generate the index name\n    const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n    // Set up the index\n    const finalIndexSpec = { name, key: indexParameters.fieldHash };\n    // merge valid index options into the index spec\n    for (const optionName in options) {\n        if (VALID_INDEX_OPTIONS.has(optionName)) {\n            finalIndexSpec[optionName] = options[optionName];\n        }\n    }\n    return finalIndexSpec;\n}\n/** @internal */\nclass IndexesOperation extends operation_1.AbstractOperation {\n    constructor(collection, options) {\n        super(options);\n        this.options = options;\n        this.collection = collection;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const options = this.options;\n        (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { full: true, ...options, readPreference: this.readPreference, session }, callback);\n    }\n}\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nclass CreateIndexesOperation extends command_1.CommandOperation {\n    constructor(parent, collectionName, indexes, options) {\n        super(parent, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collectionName = collectionName;\n        this.indexes = indexes;\n    }\n    execute(server, session, callback) {\n        const options = this.options;\n        const indexes = this.indexes;\n        const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n        // Ensure we generate the correct name if the parameter is not set\n        for (let i = 0; i < indexes.length; i++) {\n            // Did the user pass in a collation, check if our write server supports it\n            if (indexes[i].collation && serverWireVersion < 5) {\n                callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` +\n                    'does not support collation'));\n                return;\n            }\n            if (indexes[i].name == null) {\n                const keys = [];\n                for (const name in indexes[i].key) {\n                    keys.push(`${name}_${indexes[i].key[name]}`);\n                }\n                // Set the name\n                indexes[i].name = keys.join('_');\n            }\n        }\n        const cmd = { createIndexes: this.collectionName, indexes };\n        if (options.commitQuorum != null) {\n            if (serverWireVersion < 9) {\n                callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n                return;\n            }\n            cmd.commitQuorum = options.commitQuorum;\n        }\n        // collation is set on each index, it should not be defined at the root\n        this.options.collation = undefined;\n        super.executeCommand(server, session, cmd, err => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            const indexNames = indexes.map(index => index.name || '');\n            callback(undefined, indexNames);\n        });\n    }\n}\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nclass CreateIndexOperation extends CreateIndexesOperation {\n    constructor(parent, collectionName, indexSpec, options) {\n        // createIndex can be called with a variety of styles:\n        //   coll.createIndex('a');\n        //   coll.createIndex({ a: 1 });\n        //   coll.createIndex([['a', 1]]);\n        // createIndexes is always called with an array of index spec objects\n        super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n    }\n    execute(server, session, callback) {\n        super.execute(server, session, (err, indexNames) => {\n            if (err || !indexNames)\n                return callback(err);\n            return callback(undefined, indexNames[0]);\n        });\n    }\n}\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nclass EnsureIndexOperation extends CreateIndexOperation {\n    constructor(db, collectionName, indexSpec, options) {\n        super(db, collectionName, indexSpec, options);\n        this.readPreference = read_preference_1.ReadPreference.primary;\n        this.db = db;\n        this.collectionName = collectionName;\n    }\n    execute(server, session, callback) {\n        const indexName = this.indexes[0].name;\n        const cursor = this.db.collection(this.collectionName).listIndexes({ session });\n        cursor.toArray((err, indexes) => {\n            /// ignore \"NamespaceNotFound\" errors\n            if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                return callback(err);\n            }\n            if (indexes) {\n                indexes = Array.isArray(indexes) ? indexes : [indexes];\n                if (indexes.some(index => index.name === indexName)) {\n                    callback(undefined, indexName);\n                    return;\n                }\n            }\n            super.execute(server, session, callback);\n        });\n    }\n}\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nclass DropIndexOperation extends command_1.CommandOperation {\n    constructor(collection, indexName, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collection = collection;\n        this.indexName = indexName;\n    }\n    execute(server, session, callback) {\n        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n        super.executeCommand(server, session, cmd, callback);\n    }\n}\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nclass DropIndexesOperation extends DropIndexOperation {\n    constructor(collection, options) {\n        super(collection, '*', options);\n    }\n    execute(server, session, callback) {\n        super.execute(server, session, err => {\n            if (err)\n                return callback(err, false);\n            callback(undefined, true);\n        });\n    }\n}\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nclass ListIndexesOperation extends command_1.CommandOperation {\n    constructor(collection, options) {\n        super(collection, options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.collectionNamespace = collection.s.namespace;\n    }\n    execute(server, session, callback) {\n        const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n        const command = { listIndexes: this.collectionNamespace.collection, cursor };\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n            command.comment = this.options.comment;\n        }\n        super.executeCommand(server, session, command, callback);\n    }\n}\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n    constructor(collection, indexes, options) {\n        super(options);\n        this.options = options;\n        this.collection = collection;\n        this.indexes = indexes;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const indexes = this.indexes;\n        (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options, readPreference: this.readPreference, session }, (err, indexInformation) => {\n            // If we have an error return\n            if (err != null)\n                return callback(err);\n            // Let's check for the index names\n            if (!Array.isArray(indexes))\n                return callback(undefined, indexInformation[indexes] != null);\n            // Check in list of indexes\n            for (let i = 0; i < indexes.length; i++) {\n                if (indexInformation[indexes[i]] == null) {\n                    return callback(undefined, false);\n                }\n            }\n            // All keys found return true\n            return callback(undefined, true);\n        });\n    }\n}\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n    constructor(db, name, options) {\n        super(options);\n        this.options = options !== null && options !== void 0 ? options : {};\n        this.db = db;\n        this.name = name;\n    }\n    execute(server, session, callback) {\n        const db = this.db;\n        const name = this.name;\n        (0, common_functions_1.indexInformation)(db, name, { ...this.options, readPreference: this.readPreference, session }, callback);\n    }\n}\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [\n    operation_1.Aspect.READ_OPERATION,\n    operation_1.Aspect.RETRYABLE,\n    operation_1.Aspect.CURSOR_CREATING\n]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=indexes.js.map"]},"metadata":{},"sourceType":"script"}