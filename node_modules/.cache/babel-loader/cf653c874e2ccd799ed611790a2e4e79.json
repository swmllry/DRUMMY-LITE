{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\n\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(ns, pipeline, options) {\n    super(undefined, { ...options,\n      dbName: ns.db\n    });\n    this.options = options !== null && options !== void 0 ? options : {}; // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n\n    this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline; // determine if we have a write stage, override read preference if so\n\n    this.hasWriteStage = false;\n\n    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.trySecondaryWrite = true;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, {\n          writeConcern: this.writeConcern\n        });\n      }\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    command.cursor = options.cursor || {};\n\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.AggregateOperation = AggregateOperation;\n(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"sources":["../../src/operations/aggregate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\nclass AggregateOperation extends command_1.CommandOperation {\n    constructor(ns, pipeline, options) {\n        super(undefined, { ...options, dbName: ns.db });\n        this.options = options !== null && options !== void 0 ? options : {};\n        // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n        this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n        this.pipeline = pipeline;\n        // determine if we have a write stage, override read preference if so\n        this.hasWriteStage = false;\n        if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n            this.pipeline = this.pipeline.concat({ $out: options.out });\n            this.hasWriteStage = true;\n        }\n        else if (pipeline.length > 0) {\n            const finalStage = pipeline[pipeline.length - 1];\n            if (finalStage.$out || finalStage.$merge) {\n                this.hasWriteStage = true;\n            }\n        }\n        if (this.hasWriteStage) {\n            this.trySecondaryWrite = true;\n        }\n        if (this.explain && this.writeConcern) {\n            throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n        }\n        if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n        }\n    }\n    get canRetryRead() {\n        return !this.hasWriteStage;\n    }\n    addToPipeline(stage) {\n        this.pipeline.push(stage);\n    }\n    execute(server, session, callback) {\n        const options = this.options;\n        const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n        const command = { aggregate: this.target, pipeline: this.pipeline };\n        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n            this.readConcern = undefined;\n        }\n        if (serverWireVersion >= 5) {\n            if (this.hasWriteStage && this.writeConcern) {\n                Object.assign(command, { writeConcern: this.writeConcern });\n            }\n        }\n        if (options.bypassDocumentValidation === true) {\n            command.bypassDocumentValidation = options.bypassDocumentValidation;\n        }\n        if (typeof options.allowDiskUse === 'boolean') {\n            command.allowDiskUse = options.allowDiskUse;\n        }\n        if (options.hint) {\n            command.hint = options.hint;\n        }\n        if (options.let) {\n            command.let = options.let;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (options.comment !== undefined) {\n            command.comment = options.comment;\n        }\n        command.cursor = options.cursor || {};\n        if (options.batchSize && !this.hasWriteStage) {\n            command.cursor.batchSize = options.batchSize;\n        }\n        super.executeCommand(server, session, command, callback);\n    }\n}\nexports.AggregateOperation = AggregateOperation;\n(0, operation_1.defineAspects)(AggregateOperation, [\n    operation_1.Aspect.READ_OPERATION,\n    operation_1.Aspect.RETRYABLE,\n    operation_1.Aspect.EXPLAINABLE,\n    operation_1.Aspect.CURSOR_CREATING\n]);\n//# sourceMappingURL=aggregate.js.map"]},"metadata":{},"sourceType":"script"}