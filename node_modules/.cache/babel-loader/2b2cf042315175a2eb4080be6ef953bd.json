{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst bson_1 = require(\"../../bson\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst providers_1 = require(\"./providers\");\n\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n      (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback( // TODO(NODE-3483)\n    new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  let md5;\n\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n\n    throw err;\n  }\n\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n\n  return;\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n\n}\n\nexports.ScramSHA1 = ScramSHA1;\n\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n\n}\n\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"sources":["../../../src/cmap/auth/scram.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst bson_1 = require(\"../../bson\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst providers_1 = require(\"./providers\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n    constructor(cryptoMethod) {\n        super();\n        this.cryptoMethod = cryptoMethod || 'sha1';\n    }\n    prepare(handshakeDoc, authContext, callback) {\n        const cryptoMethod = this.cryptoMethod;\n        const credentials = authContext.credentials;\n        if (!credentials) {\n            return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n        }\n        if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n            (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n        crypto.randomBytes(24, (err, nonce) => {\n            if (err) {\n                return callback(err);\n            }\n            // store the nonce for later use\n            Object.assign(authContext, { nonce });\n            const request = Object.assign({}, handshakeDoc, {\n                speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n                    db: credentials.source\n                })\n            });\n            callback(undefined, request);\n        });\n    }\n    auth(authContext, callback) {\n        const response = authContext.response;\n        if (response && response.speculativeAuthenticate) {\n            continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n            return;\n        }\n        executeScram(this.cryptoMethod, authContext, callback);\n    }\n}\nfunction cleanUsername(username) {\n    return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return Buffer.concat([\n        Buffer.from('n=', 'utf8'),\n        Buffer.from(username, 'utf8'),\n        Buffer.from(',r=', 'utf8'),\n        Buffer.from(nonce.toString('base64'), 'utf8')\n    ]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n    const username = cleanUsername(credentials.username);\n    const mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return {\n        saslStart: 1,\n        mechanism,\n        payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n        autoAuthorize: 1,\n        options: { skipEmptyExchange: true }\n    };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n    connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n        const err = resolveError(_err, result);\n        if (err) {\n            return callback(err);\n        }\n        continueScramConversation(cryptoMethod, result, authContext, callback);\n    });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const username = cleanUsername(credentials.username);\n    const password = credentials.password;\n    let processedPassword;\n    if (cryptoMethod === 'sha256') {\n        processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n    }\n    else {\n        try {\n            processedPassword = passwordDigest(username, password);\n        }\n        catch (e) {\n            return callback(e);\n        }\n    }\n    const payload = Buffer.isBuffer(response.payload)\n        ? new bson_1.Binary(response.payload)\n        : response.payload;\n    const dict = parsePayload(payload.value());\n    const iterations = parseInt(dict.i, 10);\n    if (iterations && iterations < 4096) {\n        callback(\n        // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n    }\n    const salt = dict.s;\n    const rnonce = dict.r;\n    if (rnonce.startsWith('nonce')) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n    }\n    // Set up start of proof\n    const withoutProof = `c=biws,r=${rnonce}`;\n    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n    const storedKey = H(cryptoMethod, clientKey);\n    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n    const clientProof = `p=${xor(clientKey, clientSignature)}`;\n    const clientFinal = [withoutProof, clientProof].join(',');\n    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n    const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: response.conversationId,\n        payload: new bson_1.Binary(Buffer.from(clientFinal))\n    };\n    connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n        const err = resolveError(_err, r);\n        if (err) {\n            return callback(err);\n        }\n        const parsedResponse = parsePayload(r.payload.value());\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n            return;\n        }\n        if (!r || r.done !== false) {\n            return callback(err, r);\n        }\n        const retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n        };\n        connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n    });\n}\nfunction parsePayload(payload) {\n    const dict = {};\n    const parts = payload.split(',');\n    for (let i = 0; i < parts.length; i++) {\n        const valueParts = parts[i].split('=');\n        dict[valueParts[0]] = valueParts[1];\n    }\n    return dict;\n}\nfunction passwordDigest(username, password) {\n    if (typeof username !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Username must be a string');\n    }\n    if (typeof password !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Password must be a string');\n    }\n    if (password.length === 0) {\n        throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n    }\n    let md5;\n    try {\n        md5 = crypto.createHash('md5');\n    }\n    catch (err) {\n        if (crypto.getFips()) {\n            // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n            // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n            throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n        }\n        throw err;\n    }\n    md5.update(`${username}:mongo:${password}`, 'utf8');\n    return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n    if (!Buffer.isBuffer(a)) {\n        a = Buffer.from(a);\n    }\n    if (!Buffer.isBuffer(b)) {\n        b = Buffer.from(b);\n    }\n    const length = Math.max(a.length, b.length);\n    const res = [];\n    for (let i = 0; i < length; i += 1) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n    return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n    return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n    _hiCache = {};\n    _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n    sha256: 32,\n    sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n    // omit the work if already generated\n    const key = [data, salt.toString('base64'), iterations].join('_');\n    if (_hiCache[key] != null) {\n        return _hiCache[key];\n    }\n    // generate the salt\n    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n    // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n    if (_hiCacheCount >= 200) {\n        _hiCachePurge();\n    }\n    _hiCache[key] = saltedData;\n    _hiCacheCount += 1;\n    return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n    if (lhs.length !== rhs.length) {\n        return false;\n    }\n    if (typeof crypto.timingSafeEqual === 'function') {\n        return crypto.timingSafeEqual(lhs, rhs);\n    }\n    let result = 0;\n    for (let i = 0; i < lhs.length; i++) {\n        result |= lhs[i] ^ rhs[i];\n    }\n    return result === 0;\n}\nfunction resolveError(err, result) {\n    if (err)\n        return err;\n    if (result) {\n        if (result.$err || result.errmsg)\n            return new error_1.MongoServerError(result);\n    }\n    return;\n}\nclass ScramSHA1 extends ScramSHA {\n    constructor() {\n        super('sha1');\n    }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n    constructor() {\n        super('sha256');\n    }\n}\nexports.ScramSHA256 = ScramSHA256;\n//# sourceMappingURL=scram.js.map"]},"metadata":{},"sourceType":"script"}