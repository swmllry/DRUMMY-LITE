{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst commands_1 = require(\"./commands\");\n\nconst compression_1 = require(\"./wire_protocol/compression\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\n\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\n\nclass MessageStream extends stream_1.Duplex {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    /** @internal */\n\n    this.isMonitoringConnection = false;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n\n  get buffer() {\n    return this[kBuffer];\n  }\n\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read() {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    (0, compression_1.compress)({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n}\n\nexports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  const monitorHasAnotherHello = () => {\n    if (stream.isMonitoringConnection) {\n      // Can we read the next message size?\n      if (buffer.length >= 4) {\n        const sizeOfMessage = buffer.peek(4).readInt32LE();\n\n        if (sizeOfMessage <= buffer.length) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE); // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n\n    if (monitorHasAnotherHello()) {\n      processIncomingData(stream, callback);\n    } else {\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n      if (buffer.length >= 4) {\n        processIncomingData(stream, callback);\n      } else {\n        callback();\n      }\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  (0, compression_1.decompress)(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    } // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n\n\n    if (monitorHasAnotherHello()) {\n      processIncomingData(stream, callback);\n    } else {\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n      if (buffer.length >= 4) {\n        processIncomingData(stream, callback);\n      } else {\n        callback();\n      }\n    }\n  });\n}","map":{"version":3,"sources":["../../src/cmap/message_stream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageStream = void 0;\nconst stream_1 = require(\"stream\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst commands_1 = require(\"./commands\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nclass MessageStream extends stream_1.Duplex {\n    constructor(options = {}) {\n        super(options);\n        /** @internal */\n        this.isMonitoringConnection = false;\n        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n        this[kBuffer] = new utils_1.BufferPool();\n    }\n    get buffer() {\n        return this[kBuffer];\n    }\n    _write(chunk, _, callback) {\n        this[kBuffer].append(chunk);\n        processIncomingData(this, callback);\n    }\n    _read( /* size */) {\n        // NOTE: This implementation is empty because we explicitly push data to be read\n        //       when `writeMessage` is called.\n        return;\n    }\n    writeCommand(command, operationDescription) {\n        // TODO: agreed compressor should live in `StreamDescription`\n        const compressorName = operationDescription && operationDescription.agreedCompressor\n            ? operationDescription.agreedCompressor\n            : 'none';\n        if (compressorName === 'none' || !canCompress(command)) {\n            const data = command.toBin();\n            this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n            return;\n        }\n        // otherwise, compress the message\n        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n        // Extract information needed for OP_COMPRESSED from the uncompressed message\n        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n        // Compress the message body\n        (0, compression_1.compress)({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n            if (err || !compressedMessage) {\n                operationDescription.cb(err);\n                return;\n            }\n            // Create the msgHeader of OP_COMPRESSED\n            const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n            msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n            msgHeader.writeInt32LE(command.requestId, 4); // requestID\n            msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n            msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n            // Create the compression details of OP_COMPRESSED\n            const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n            compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n            compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n            compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n            this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n        });\n    }\n}\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n    const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n    const commandName = Object.keys(commandDoc)[0];\n    return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n    const buffer = stream[kBuffer];\n    if (buffer.length < 4) {\n        callback();\n        return;\n    }\n    const sizeOfMessage = buffer.peek(4).readInt32LE();\n    if (sizeOfMessage < 0) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n        return;\n    }\n    if (sizeOfMessage > stream.maxBsonMessageSize) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n        return;\n    }\n    if (sizeOfMessage > buffer.length) {\n        callback();\n        return;\n    }\n    const message = buffer.read(sizeOfMessage);\n    const messageHeader = {\n        length: message.readInt32LE(0),\n        requestId: message.readInt32LE(4),\n        responseTo: message.readInt32LE(8),\n        opCode: message.readInt32LE(12)\n    };\n    const monitorHasAnotherHello = () => {\n        if (stream.isMonitoringConnection) {\n            // Can we read the next message size?\n            if (buffer.length >= 4) {\n                const sizeOfMessage = buffer.peek(4).readInt32LE();\n                if (sizeOfMessage <= buffer.length) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n        const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n        // If we are a monitoring connection message stream and\n        // there is more in the buffer that can be read, skip processing since we\n        // want the last hello command response that is in the buffer.\n        if (monitorHasAnotherHello()) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n            if (buffer.length >= 4) {\n                processIncomingData(stream, callback);\n            }\n            else {\n                callback();\n            }\n        }\n        return;\n    }\n    messageHeader.fromCompressed = true;\n    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n    const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n    // recalculate based on wrapped opcode\n    ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    (0, compression_1.decompress)(compressorID, compressedBuffer, (err, messageBody) => {\n        if (err || !messageBody) {\n            callback(err);\n            return;\n        }\n        if (messageBody.length !== messageHeader.length) {\n            callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n            return;\n        }\n        // If we are a monitoring connection message stream and\n        // there is more in the buffer that can be read, skip processing since we\n        // want the last hello command response that is in the buffer.\n        if (monitorHasAnotherHello()) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n            if (buffer.length >= 4) {\n                processIncomingData(stream, callback);\n            }\n            else {\n                callback();\n            }\n        }\n    });\n}\n//# sourceMappingURL=message_stream.js.map"]},"metadata":{},"sourceType":"script"}