{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\n\nconst net = require(\"net\");\n\nconst socks_1 = require(\"socks\");\n\nconst tls = require(\"tls\");\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst gssapi_1 = require(\"./auth/gssapi\");\n\nconst mongocr_1 = require(\"./auth/mongocr\");\n\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\n\nconst plain_1 = require(\"./auth/plain\");\n\nconst providers_1 = require(\"./auth/providers\");\n\nconst scram_1 = require(\"./auth/scram\");\n\nconst x509_1 = require(\"./auth/x509\");\n\nconst connection_1 = require(\"./connection\");\n\nconst constants_2 = require(\"./wire_protocol/constants\");\n\nconst AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\n\nfunction connect(options, callback) {\n  makeConnection({ ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    var _a;\n\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(hello, options) {\n  var _a;\n\n  const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n\n        provider.auth(authContext, err => {\n          if (err) {\n            if (err instanceof error_1.MongoError) {\n              err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n\n              if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n              }\n            }\n\n            return callback(err);\n          }\n\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n    helloOk: true,\n    client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n/** @public */\n\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  const existingSocket = options.existingSocket;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({ ...options,\n      connectTimeoutMS // Should always be present for Socks5\n\n    }, callback);\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options, callback) {\n  var _a, _b;\n\n  const hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '', // proxyHost is guaranteed to set here\n  (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080); // First, connect to the proxy server itself:\n\n  makeConnection({ ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const destination = parseConnectOptions(options);\n\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    } // Then, establish the Socks5 proxy connection:\n\n\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(_ref => {\n      let {\n        socket\n      } = _ref;\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection({ ...options,\n        existingSocket: socket,\n        proxyHost: undefined\n      }, callback);\n    }, error => callback(connectionFailureError('error', error)));\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"sources":["../../src/cmap/connect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\nconst net = require(\"net\");\nconst socks_1 = require(\"socks\");\nconst tls = require(\"tls\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst gssapi_1 = require(\"./auth/gssapi\");\nconst mongocr_1 = require(\"./auth/mongocr\");\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nconst plain_1 = require(\"./auth/plain\");\nconst providers_1 = require(\"./auth/providers\");\nconst scram_1 = require(\"./auth/scram\");\nconst x509_1 = require(\"./auth/x509\");\nconst connection_1 = require(\"./connection\");\nconst constants_2 = require(\"./wire_protocol/constants\");\nconst AUTH_PROVIDERS = new Map([\n    [providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()],\n    [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()],\n    [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()],\n    [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()],\n    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()],\n    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()],\n    [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]\n]);\nfunction connect(options, callback) {\n    makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\n        var _a;\n        if (err || !socket) {\n            return callback(err);\n        }\n        let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n        if (options.autoEncrypter) {\n            ConnectionType = connection_1.CryptoConnection;\n        }\n        performInitialHandshake(new ConnectionType(socket, options), options, callback);\n    });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n    var _a;\n    const serverVersionHighEnough = hello &&\n        (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) &&\n        hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n    const serverVersionLowEnough = hello &&\n        (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) &&\n        hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n    if (serverVersionHighEnough) {\n        if (serverVersionLowEnough) {\n            return null;\n        }\n        const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n        return new error_1.MongoCompatibilityError(message);\n    }\n    const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n    const callback = function (err, ret) {\n        if (err && conn) {\n            conn.destroy();\n        }\n        _callback(err, ret);\n    };\n    const credentials = options.credentials;\n    if (credentials) {\n        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) &&\n            !AUTH_PROVIDERS.get(credentials.mechanism)) {\n            callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n            return;\n        }\n    }\n    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n    prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n        if (err || !handshakeDoc) {\n            return callback(err);\n        }\n        const handshakeOptions = Object.assign({}, options);\n        if (typeof options.connectTimeoutMS === 'number') {\n            // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n            handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n        }\n        const start = new Date().getTime();\n        conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n                callback(new error_1.MongoServerError(response));\n                return;\n            }\n            if (!('isWritablePrimary' in response)) {\n                // Provide hello-style response document.\n                response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n            }\n            if (response.helloOk) {\n                conn.helloOk = true;\n            }\n            const supportedServerErr = checkSupportedServer(response, options);\n            if (supportedServerErr) {\n                callback(supportedServerErr);\n                return;\n            }\n            if (options.loadBalanced) {\n                if (!response.serviceId) {\n                    return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +\n                        'but the server does not support this mode.'));\n                }\n            }\n            // NOTE: This is metadata attached to the connection while porting away from\n            //       handshake being done in the `Server` class. Likely, it should be\n            //       relocated, or at very least restructured.\n            conn.hello = response;\n            conn.lastHelloMS = new Date().getTime() - start;\n            if (!response.arbiterOnly && credentials) {\n                // store the response on auth context\n                authContext.response = response;\n                const resolvedCredentials = credentials.resolveAuthMechanism(response);\n                const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n                if (!provider) {\n                    return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n                }\n                provider.auth(authContext, err => {\n                    if (err) {\n                        if (err instanceof error_1.MongoError) {\n                            err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n                            if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {\n                                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n                            }\n                        }\n                        return callback(err);\n                    }\n                    callback(undefined, conn);\n                });\n                return;\n            }\n            callback(undefined, conn);\n        });\n    });\n}\nfunction prepareHandshakeDocument(authContext, callback) {\n    const options = authContext.options;\n    const compressors = options.compressors ? options.compressors : [];\n    const { serverApi } = authContext.connection;\n    const handshakeDoc = {\n        [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: true,\n        helloOk: true,\n        client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n        compression: compressors,\n        loadBalanced: options.loadBalanced\n    };\n    const credentials = authContext.credentials;\n    if (credentials) {\n        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n            handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n            const provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n            if (!provider) {\n                // This auth mechanism is always present.\n                return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n            }\n            return provider.prepare(handshakeDoc, authContext, callback);\n        }\n        const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n        if (!provider) {\n            return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n        }\n        return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    callback(undefined, handshakeDoc);\n}\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = [\n    'ALPNProtocols',\n    'ca',\n    'cert',\n    'checkServerIdentity',\n    'ciphers',\n    'crl',\n    'ecdhCurve',\n    'key',\n    'minDHSize',\n    'passphrase',\n    'pfx',\n    'rejectUnauthorized',\n    'secureContext',\n    'secureProtocol',\n    'servername',\n    'session'\n];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = [\n    'family',\n    'hints',\n    'localAddress',\n    'localPort',\n    'lookup'\n];\nfunction parseConnectOptions(options) {\n    const hostAddress = options.hostAddress;\n    if (!hostAddress)\n        throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n    const result = {};\n    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (typeof hostAddress.socketPath === 'string') {\n        result.path = hostAddress.socketPath;\n        return result;\n    }\n    else if (typeof hostAddress.host === 'string') {\n        result.host = hostAddress.host;\n        result.port = hostAddress.port;\n        return result;\n    }\n    else {\n        // This should never happen since we set up HostAddresses\n        // But if we don't throw here the socket could hang until timeout\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n    }\n}\nfunction parseSslOptions(options) {\n    const result = parseConnectOptions(options);\n    // Merge in valid SSL options\n    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (options.existingSocket) {\n        result.socket = options.existingSocket;\n    }\n    // Set default sni servername to be the same as host\n    if (result.servername == null && result.host && !net.isIP(result.host)) {\n        result.servername = result.host;\n    }\n    return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n    const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n    const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n    const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n    const connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n    const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n    const keepAliveInitialDelay = (_j = (((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS\n        ? Math.round(socketTimeoutMS / 2)\n        : options.keepAliveInitialDelay)) !== null && _j !== void 0 ? _j : 120000;\n    const existingSocket = options.existingSocket;\n    let socket;\n    const callback = function (err, ret) {\n        if (err && socket) {\n            socket.destroy();\n        }\n        _callback(err, ret);\n    };\n    if (options.proxyHost != null) {\n        // Currently, only Socks5 is supported.\n        return makeSocks5Connection({\n            ...options,\n            connectTimeoutMS // Should always be present for Socks5\n        }, callback);\n    }\n    if (useTLS) {\n        const tlsSocket = tls.connect(parseSslOptions(options));\n        if (typeof tlsSocket.disableRenegotiation === 'function') {\n            tlsSocket.disableRenegotiation();\n        }\n        socket = tlsSocket;\n    }\n    else if (existingSocket) {\n        // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n        // so we only need to handle the non-TLS case here (where existingSocket\n        // gives us all we need out of the box).\n        socket = existingSocket;\n    }\n    else {\n        socket = net.createConnection(parseConnectOptions(options));\n    }\n    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n    socket.setTimeout(connectTimeoutMS);\n    socket.setNoDelay(noDelay);\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    let cancellationHandler;\n    function errorHandler(eventName) {\n        return (err) => {\n            SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n            if (cancellationHandler && options.cancellationToken) {\n                options.cancellationToken.removeListener('cancel', cancellationHandler);\n            }\n            socket.removeListener(connectEvent, connectHandler);\n            callback(connectionFailureError(eventName, err));\n        };\n    }\n    function connectHandler() {\n        SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n        if (cancellationHandler && options.cancellationToken) {\n            options.cancellationToken.removeListener('cancel', cancellationHandler);\n        }\n        if ('authorizationError' in socket) {\n            if (socket.authorizationError && rejectUnauthorized) {\n                return callback(socket.authorizationError);\n            }\n        }\n        socket.setTimeout(socketTimeoutMS);\n        callback(undefined, socket);\n    }\n    SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n    if (options.cancellationToken) {\n        cancellationHandler = errorHandler('cancel');\n        options.cancellationToken.once('cancel', cancellationHandler);\n    }\n    if (existingSocket) {\n        process.nextTick(connectHandler);\n    }\n    else {\n        socket.once(connectEvent, connectHandler);\n    }\n}\nfunction makeSocks5Connection(options, callback) {\n    var _a, _b;\n    const hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '', // proxyHost is guaranteed to set here\n    (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080);\n    // First, connect to the proxy server itself:\n    makeConnection({\n        ...options,\n        hostAddress,\n        tls: false,\n        proxyHost: undefined\n    }, (err, rawSocket) => {\n        if (err) {\n            return callback(err);\n        }\n        const destination = parseConnectOptions(options);\n        if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n            return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n        }\n        // Then, establish the Socks5 proxy connection:\n        socks_1.SocksClient.createConnection({\n            existing_socket: rawSocket,\n            timeout: options.connectTimeoutMS,\n            command: 'connect',\n            destination: {\n                host: destination.host,\n                port: destination.port\n            },\n            proxy: {\n                // host and port are ignored because we pass existing_socket\n                host: 'iLoveJavaScript',\n                port: 0,\n                type: 5,\n                userId: options.proxyUsername || undefined,\n                password: options.proxyPassword || undefined\n            }\n        }).then(({ socket }) => {\n            // Finally, now treat the resulting duplex stream as the\n            // socket over which we send and receive wire protocol messages:\n            makeConnection({\n                ...options,\n                existingSocket: socket,\n                proxyHost: undefined\n            }, callback);\n        }, error => callback(connectionFailureError('error', error)));\n    });\n}\nfunction connectionFailureError(type, err) {\n    switch (type) {\n        case 'error':\n            return new error_1.MongoNetworkError(err);\n        case 'timeout':\n            return new error_1.MongoNetworkTimeoutError('connection timed out');\n        case 'close':\n            return new error_1.MongoNetworkError('connection closed');\n        case 'cancel':\n            return new error_1.MongoNetworkError('connection establishment was cancelled');\n        default:\n            return new error_1.MongoNetworkError('unknown network error');\n    }\n}\n//# sourceMappingURL=connect.js.map"]},"metadata":{},"sourceType":"script"}