{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst server_selection_1 = require(\"../sdam/server_selection\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(client, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return (0, utils_1.maybePromise)(callback, callback => {\n    const topology = client.topology;\n\n    if (topology == null) {\n      if (client.s.hasBeenClosed) {\n        return callback(new error_1.MongoNotConnectedError('Client must be connected before running operations'));\n      }\n\n      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n      return client.connect(error => {\n        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n\n        if (error) {\n          return callback(error);\n        }\n\n        return executeOperation(client, operation, callback);\n      });\n    }\n\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, err => {\n        if (err) return callback(err);\n        executeOperation(client, operation, callback);\n      });\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = client.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else {\n      // no session support\n      if (session && session.explicit) {\n        // If the user passed an explicit session and we are still, after server selection,\n        // trying to run against a topology that doesn't support sessions we error out.\n        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n      } else if (session && !session.explicit) {\n        // We do not have to worry about ending the session because the server session has not been acquired yet\n        delete operation.options.session;\n        operation.clearSession();\n        session = undefined;\n      }\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (error, result) => {\n        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n          return session.endSession(endSessionError => callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result));\n        }\n\n        callback(error, result);\n      });\n    } catch (error) {\n      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n        session.endSession().catch(() => null);\n      }\n\n      throw error;\n    }\n  });\n}\n\nexports.executeOperation = executeOperation;\n\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  var _a, _b;\n\n  const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    return callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector;\n\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const serverSelectionOptions = {\n    session\n  };\n\n  function retryOperation(originalError) {\n    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      return callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError\n      }));\n    }\n\n    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n      return callback(originalError);\n    }\n\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n      return callback(originalError);\n    }\n\n    if (originalError instanceof error_1.MongoNetworkError && (session === null || session === void 0 ? void 0 : session.isPinned) && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({\n        force: true,\n        forceClear: true\n      });\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n      if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n        return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));\n      }\n\n      if (error || !server) {\n        return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && (session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n    if (error || !server) {\n      return callback(error);\n    }\n\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        return operation.execute(server, session, (error, result) => {\n          if (error instanceof error_1.MongoError) {\n            return retryOperation(error);\n          } else if (error) {\n            return callback(error);\n          }\n\n          callback(undefined, result);\n        });\n      }\n    }\n\n    return operation.execute(server, session, callback);\n  });\n}","map":{"version":3,"sources":["../../src/operations/execute_operation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n        // TODO(NODE-3483): Extend MongoRuntimeError\n        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n    return (0, utils_1.maybePromise)(callback, callback => {\n        const topology = client.topology;\n        if (topology == null) {\n            if (client.s.hasBeenClosed) {\n                return callback(new error_1.MongoNotConnectedError('Client must be connected before running operations'));\n            }\n            client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n            return client.connect(error => {\n                delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n                if (error) {\n                    return callback(error);\n                }\n                return executeOperation(client, operation, callback);\n            });\n        }\n        if (topology.shouldCheckForSessionSupport()) {\n            return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, err => {\n                if (err)\n                    return callback(err);\n                executeOperation(client, operation, callback);\n            });\n        }\n        // The driver sessions spec mandates that we implicitly create sessions for operations\n        // that are not explicitly provided with a session.\n        let session = operation.session;\n        let owner;\n        if (topology.hasSessionSupport()) {\n            if (session == null) {\n                owner = Symbol();\n                session = client.startSession({ owner, explicit: false });\n            }\n            else if (session.hasEnded) {\n                return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n            }\n            else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n                return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n            }\n        }\n        else {\n            // no session support\n            if (session && session.explicit) {\n                // If the user passed an explicit session and we are still, after server selection,\n                // trying to run against a topology that doesn't support sessions we error out.\n                return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n            }\n            else if (session && !session.explicit) {\n                // We do not have to worry about ending the session because the server session has not been acquired yet\n                delete operation.options.session;\n                operation.clearSession();\n                session = undefined;\n            }\n        }\n        try {\n            executeWithServerSelection(topology, session, operation, (error, result) => {\n                if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n                    return session.endSession(endSessionError => callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result));\n                }\n                callback(error, result);\n            });\n        }\n        catch (error) {\n            if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n                session.endSession().catch(() => null);\n            }\n            throw error;\n        }\n    });\n}\nexports.executeOperation = executeOperation;\nfunction executeWithServerSelection(topology, session, operation, callback) {\n    var _a, _b;\n    const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n        return callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    }\n    if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n        session.unpin();\n    }\n    let selector;\n    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n        // GetMore and KillCursor operations must always select the same server, but run through\n        // server selection to potentially force monitor checks if the server is\n        // in an unknown state.\n        selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n    }\n    else if (operation.trySecondaryWrite) {\n        // If operation should try to write to secondary use the custom server selector\n        // otherwise provide the read preference.\n        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n    }\n    else {\n        selector = readPreference;\n    }\n    const serverSelectionOptions = { session };\n    function retryOperation(originalError) {\n        const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n        const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n        if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n            return callback(new error_1.MongoServerError({\n                message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                originalError\n            }));\n        }\n        if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n            return callback(originalError);\n        }\n        if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n            return callback(originalError);\n        }\n        if (originalError instanceof error_1.MongoNetworkError &&\n            (session === null || session === void 0 ? void 0 : session.isPinned) &&\n            !session.inTransaction() &&\n            operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n            // If we have a cursor and the initial command fails with a network error,\n            // we can retry it on another connection. So we need to check it back in, clear the\n            // pool for the service id, and retry again.\n            session.unpin({ force: true, forceClear: true });\n        }\n        // select a new server, and attempt to retry the operation\n        topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n            if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n                return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));\n            }\n            if (error || !server) {\n                return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));\n            }\n            operation.execute(server, session, callback);\n        });\n    }\n    if (readPreference &&\n        !readPreference.equals(read_preference_1.ReadPreference.primary) &&\n        (session === null || session === void 0 ? void 0 : session.inTransaction())) {\n        callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n        return;\n    }\n    // select a server, and execute the operation against it\n    topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n        if (error || !server) {\n            return callback(error);\n        }\n        if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n            const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n            const willRetryWrite = topology.s.options.retryWrites &&\n                !inTransaction &&\n                (0, utils_1.supportsRetryableWrites)(server) &&\n                operation.canRetryWrite;\n            const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n            const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n            if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n                if (hasWriteAspect && willRetryWrite) {\n                    operation.options.willRetryWrite = true;\n                    session.incrementTransactionNumber();\n                }\n                return operation.execute(server, session, (error, result) => {\n                    if (error instanceof error_1.MongoError) {\n                        return retryOperation(error);\n                    }\n                    else if (error) {\n                        return callback(error);\n                    }\n                    callback(undefined, result);\n                });\n            }\n        }\n        return operation.execute(server, session, callback);\n    });\n}\n//# sourceMappingURL=execute_operation.js.map"]},"metadata":{},"sourceType":"script"}