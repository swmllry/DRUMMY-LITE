{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PromiseProvider = void 0;\n\nconst error_1 = require(\"./error\");\n/** @internal */\n\n\nconst kPromise = Symbol('promise');\nconst store = {\n  [kPromise]: undefined\n};\n/**\n * Global promise store allowing user-provided promises\n * @public\n */\n\nclass PromiseProvider {\n  /** Validates the passed in promise library */\n  static validate(lib) {\n    if (typeof lib !== 'function') throw new error_1.MongoInvalidArgumentError(`Promise must be a function, got ${lib}`);\n    return !!lib;\n  }\n  /** Sets the promise library */\n\n\n  static set(lib) {\n    if (!PromiseProvider.validate(lib)) {\n      // validate\n      return;\n    }\n\n    store[kPromise] = lib;\n  }\n  /** Get the stored promise library, or resolves passed in */\n\n\n  static get() {\n    return store[kPromise];\n  }\n\n}\n\nexports.PromiseProvider = PromiseProvider;\nPromiseProvider.set(global.Promise);","map":{"version":3,"sources":["../src/promise_provider.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;AACA,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAD,CAAvB;AAMA,MAAM,KAAK,GAAiB;EAC1B,CAAC,QAAD,GAAY;AADc,CAA5B;AAIA;;;AAGG;;AACH,MAAa,eAAb,CAA4B;EAC1B;EACe,OAAR,QAAQ,CAAC,GAAD,EAAa;IAC1B,IAAI,OAAO,GAAP,KAAe,UAAnB,EACE,MAAM,IAAI,OAAA,CAAA,yBAAJ,CAA8B,mCAAmC,GAAG,EAApE,CAAN;IACF,OAAO,CAAC,CAAC,GAAT;EACD;EAED;;;EACU,OAAH,GAAG,CAAC,GAAD,EAAwB;IAChC,IAAI,CAAC,eAAe,CAAC,QAAhB,CAAyB,GAAzB,CAAL,EAAoC;MAClC;MACA;IACD;;IACD,KAAK,CAAC,QAAD,CAAL,GAAkB,GAAlB;EACD;EAED;;;EACU,OAAH,GAAG,GAAA;IACR,OAAO,KAAK,CAAC,QAAD,CAAZ;EACD;;AApByB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA;AAuBA,eAAe,CAAC,GAAhB,CAAoB,MAAM,CAAC,OAA3B","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PromiseProvider = void 0;\nconst error_1 = require(\"./error\");\n/** @internal */\nconst kPromise = Symbol('promise');\nconst store = {\n    [kPromise]: undefined\n};\n/**\n * Global promise store allowing user-provided promises\n * @public\n */\nclass PromiseProvider {\n    /** Validates the passed in promise library */\n    static validate(lib) {\n        if (typeof lib !== 'function')\n            throw new error_1.MongoInvalidArgumentError(`Promise must be a function, got ${lib}`);\n        return !!lib;\n    }\n    /** Sets the promise library */\n    static set(lib) {\n        if (!PromiseProvider.validate(lib)) {\n            // validate\n            return;\n        }\n        store[kPromise] = lib;\n    }\n    /** Get the stored promise library, or resolves passed in */\n    static get() {\n        return store[kPromise];\n    }\n}\nexports.PromiseProvider = PromiseProvider;\nPromiseProvider.set(global.Promise);\n//# sourceMappingURL=promise_provider.js.map"]},"metadata":{},"sourceType":"script"}