{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst common_1 = require(\"./common\"); // max staleness constants\n\n\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90; //  Minimum version to try writes on secondaries.\n\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\n * Returns a server selector that selects for writable servers\n */\n\nfunction writableServerSelector() {\n  return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter(s => s.isWritable));\n}\n\nexports.writableServerSelector = writableServerSelector;\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\n\nfunction sameServerSelector(description) {\n  return (topologyDescription, servers) => {\n    if (!description) return []; // Filter the servers to match the provided description only if\n    // the type is not unknown.\n\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n    });\n  };\n}\n\nexports.sameServerSelector = sameServerSelector;\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\n\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {\n    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n  }\n\n  return readPreferenceServerSelector(readPreference);\n}\n\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\n\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n    return servers.reduce((result, server) => {\n      var _a;\n\n      const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\n\n\nfunction tagSetMatch(tagSet, serverTags) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\n\n\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce((matched, server) => {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\n\n\nfunction latencyWindowReducer(topologyDescription, servers) {\n  const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result, server) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n} // filters\n\n\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\n\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\n\n\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return (topologyDescription, servers) => {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":{"version":3,"sources":["../../src/sdam/server_selection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst common_1 = require(\"./common\");\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n//  Minimum version to try writes on secondaries.\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n    return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));\n}\nexports.writableServerSelector = writableServerSelector;\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nfunction sameServerSelector(description) {\n    return (topologyDescription, servers) => {\n        if (!description)\n            return [];\n        // Filter the servers to match the provided description only if\n        // the type is not unknown.\n        return servers.filter(sd => {\n            return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n        });\n    };\n}\nexports.sameServerSelector = sameServerSelector;\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n    // If server version < 5.0, read preference always primary.\n    // If server version >= 5.0...\n    // - If read preference is supplied, use that.\n    // - If no read preference is supplied, use primary.\n    if (!readPreference ||\n        !wireVersion ||\n        (wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION)) {\n        return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n    }\n    return readPreferenceServerSelector(readPreference);\n}\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n        return servers;\n    }\n    const maxStaleness = readPreference.maxStalenessSeconds;\n    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n    if (maxStaleness < maxStalenessVariance) {\n        throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`);\n    }\n    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n        throw new error_1.MongoInvalidArgumentError(`Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);\n    }\n    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n        return servers.reduce((result, server) => {\n            var _a;\n            const stalenessMS = server.lastUpdateTime -\n                server.lastWriteDate -\n                (primary.lastUpdateTime - primary.lastWriteDate) +\n                topologyDescription.heartbeatFrequencyMS;\n            const staleness = stalenessMS / 1000;\n            const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n            if (staleness <= maxStalenessSeconds) {\n                result.push(server);\n            }\n            return result;\n        }, []);\n    }\n    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n        if (servers.length === 0) {\n            return servers;\n        }\n        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);\n        return servers.reduce((result, server) => {\n            var _a;\n            const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n            const staleness = stalenessMS / 1000;\n            const maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n            if (staleness <= maxStalenessSeconds) {\n                result.push(server);\n            }\n            return result;\n        }, []);\n    }\n    return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n    const keys = Object.keys(tagSet);\n    const serverTagKeys = Object.keys(serverTags);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n    if (readPreference.tags == null ||\n        (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)) {\n        return servers;\n    }\n    for (let i = 0; i < readPreference.tags.length; ++i) {\n        const tagSet = readPreference.tags[i];\n        const serversMatchingTagset = servers.reduce((matched, server) => {\n            if (tagSetMatch(tagSet, server.tags))\n                matched.push(server);\n            return matched;\n        }, []);\n        if (serversMatchingTagset.length) {\n            return serversMatchingTagset;\n        }\n    }\n    return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);\n    const high = low + topologyDescription.localThresholdMS;\n    return servers.reduce((result, server) => {\n        if (server.roundTripTime <= high && server.roundTripTime >= low)\n            result.push(server);\n        return result;\n    }, []);\n}\n// filters\nfunction primaryFilter(server) {\n    return server.type === common_1.ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n    return server.type === common_1.ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n    return server.type !== common_1.ServerType.Unknown;\n}\nfunction loadBalancerFilter(server) {\n    return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n    if (!readPreference.isValid()) {\n        throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n    }\n    return (topologyDescription, servers) => {\n        const commonWireVersion = topologyDescription.commonWireVersion;\n        if (commonWireVersion &&\n            readPreference.minWireVersion &&\n            readPreference.minWireVersion > commonWireVersion) {\n            throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);\n        }\n        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n            return servers.filter(loadBalancerFilter);\n        }\n        if (topologyDescription.type === common_1.TopologyType.Unknown) {\n            return [];\n        }\n        if (topologyDescription.type === common_1.TopologyType.Single ||\n            topologyDescription.type === common_1.TopologyType.Sharded) {\n            return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n        }\n        const mode = readPreference.mode;\n        if (mode === read_preference_1.ReadPreference.PRIMARY) {\n            return servers.filter(primaryFilter);\n        }\n        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n            const result = servers.filter(primaryFilter);\n            if (result.length) {\n                return result;\n            }\n        }\n        const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n            return servers.filter(primaryFilter);\n        }\n        return selectedServers;\n    };\n}\nexports.readPreferenceServerSelector = readPreferenceServerSelector;\n//# sourceMappingURL=server_selection.js.map"]},"metadata":{},"sourceType":"script"}