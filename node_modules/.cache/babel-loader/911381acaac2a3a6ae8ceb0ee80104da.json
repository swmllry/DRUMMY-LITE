{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatSort = void 0;\n\nconst error_1 = require(\"./error\");\n/** @internal */\n\n\nfunction prepareDirection() {\n  let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n/** @internal */\n\n\nfunction isMeta(t) {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n/** @internal */\n\n\nfunction isPair(t) {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction isDeep(t) {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\n\nfunction isMap(t) {\n  return t instanceof Map && t.size > 0;\n}\n/** @internal */\n\n\nfunction pairToMap(v) {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n/** @internal */\n\n\nfunction deepToMap(t) {\n  const sortEntries = t.map(_ref => {\n    let [k, v] = _ref;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction stringsToMap(t) {\n  const sortEntries = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction objectToMap(t) {\n  const sortEntries = Object.entries(t).map(_ref2 => {\n    let [k, v] = _ref2;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction mapToMap(t) {\n  const sortEntries = Array.from(t).map(_ref3 => {\n    let [k, v] = _ref3;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\n\n\nfunction formatSort(sort, direction) {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);\n\n  if (typeof sort !== 'object') {\n    throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);\n  }\n\n  if (!Array.isArray(sort)) {\n    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n  }\n\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort);\n  if (isPair(sort)) return pairToMap(sort);\n  return stringsToMap(sort);\n}\n\nexports.formatSort = formatSort;","map":{"version":3,"sources":["../src/sort.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatSort = void 0;\nconst error_1 = require(\"./error\");\n/** @internal */\nfunction prepareDirection(direction = 1) {\n    const value = `${direction}`.toLowerCase();\n    if (isMeta(direction))\n        return direction;\n    switch (value) {\n        case 'ascending':\n        case 'asc':\n        case '1':\n            return 1;\n        case 'descending':\n        case 'desc':\n        case '-1':\n            return -1;\n        default:\n            throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n    }\n}\n/** @internal */\nfunction isMeta(t) {\n    return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n/** @internal */\nfunction isPair(t) {\n    if (Array.isArray(t) && t.length === 2) {\n        try {\n            prepareDirection(t[1]);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    return false;\n}\nfunction isDeep(t) {\n    return Array.isArray(t) && Array.isArray(t[0]);\n}\nfunction isMap(t) {\n    return t instanceof Map && t.size > 0;\n}\n/** @internal */\nfunction pairToMap(v) {\n    return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n/** @internal */\nfunction deepToMap(t) {\n    const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);\n    return new Map(sortEntries);\n}\n/** @internal */\nfunction stringsToMap(t) {\n    const sortEntries = t.map(key => [`${key}`, 1]);\n    return new Map(sortEntries);\n}\n/** @internal */\nfunction objectToMap(t) {\n    const sortEntries = Object.entries(t).map(([k, v]) => [\n        `${k}`,\n        prepareDirection(v)\n    ]);\n    return new Map(sortEntries);\n}\n/** @internal */\nfunction mapToMap(t) {\n    const sortEntries = Array.from(t).map(([k, v]) => [\n        `${k}`,\n        prepareDirection(v)\n    ]);\n    return new Map(sortEntries);\n}\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nfunction formatSort(sort, direction) {\n    if (sort == null)\n        return undefined;\n    if (typeof sort === 'string')\n        return new Map([[sort, prepareDirection(direction)]]);\n    if (typeof sort !== 'object') {\n        throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);\n    }\n    if (!Array.isArray(sort)) {\n        return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n    }\n    if (!sort.length)\n        return undefined;\n    if (isDeep(sort))\n        return deepToMap(sort);\n    if (isPair(sort))\n        return pairToMap(sort);\n    return stringsToMap(sort);\n}\nexports.formatSort = formatSort;\n//# sourceMappingURL=sort.js.map"]},"metadata":{},"sourceType":"script"}