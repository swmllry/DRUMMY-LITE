{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst bulk_write_1 = require(\"./bulk_write\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _a;\n\n    super(undefined, options);\n    this.options = { ...options,\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server, session, callback) {\n    var _a;\n\n    const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.InsertOperation = InsertOperation;\n\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      var _a, _b;\n\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n\n}\n\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\n\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = { ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      var _a;\n\n      if (err || res == null) {\n        if (err && err.message === 'Operation must be an object with an operation key') {\n          err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n        }\n\n        return callback(err);\n      }\n\n      callback(undefined, {\n        acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n\n}\n\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"sources":["../../src/operations/insert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nconst error_1 = require(\"../error\");\nconst write_concern_1 = require(\"../write_concern\");\nconst bulk_write_1 = require(\"./bulk_write\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass InsertOperation extends command_1.CommandOperation {\n    constructor(ns, documents, options) {\n        var _a;\n        super(undefined, options);\n        this.options = { ...options, checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false };\n        this.ns = ns;\n        this.documents = documents;\n    }\n    execute(server, session, callback) {\n        var _a;\n        const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n        const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n        const command = {\n            insert: this.ns.collection,\n            documents: this.documents,\n            ordered\n        };\n        if (typeof options.bypassDocumentValidation === 'boolean') {\n            command.bypassDocumentValidation = options.bypassDocumentValidation;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (options.comment !== undefined) {\n            command.comment = options.comment;\n        }\n        super.executeCommand(server, session, command, callback);\n    }\n}\nexports.InsertOperation = InsertOperation;\nclass InsertOneOperation extends InsertOperation {\n    constructor(collection, doc, options) {\n        super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n    }\n    execute(server, session, callback) {\n        super.execute(server, session, (err, res) => {\n            var _a, _b;\n            if (err || res == null)\n                return callback(err);\n            if (res.code)\n                return callback(new error_1.MongoServerError(res));\n            if (res.writeErrors) {\n                // This should be a WriteError but we can't change it now because of error hierarchy\n                return callback(new error_1.MongoServerError(res.writeErrors[0]));\n            }\n            callback(undefined, {\n                acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n                insertedId: this.documents[0]._id\n            });\n        });\n    }\n}\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nclass InsertManyOperation extends operation_1.AbstractOperation {\n    constructor(collection, docs, options) {\n        super(options);\n        if (!Array.isArray(docs)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n        }\n        this.options = options;\n        this.collection = collection;\n        this.docs = docs;\n    }\n    execute(server, session, callback) {\n        const coll = this.collection;\n        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n        const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({ insertOne: { document } })), options);\n        bulkWriteOperation.execute(server, session, (err, res) => {\n            var _a;\n            if (err || res == null) {\n                if (err && err.message === 'Operation must be an object with an operation key') {\n                    err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n                }\n                return callback(err);\n            }\n            callback(undefined, {\n                acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n                insertedCount: res.insertedCount,\n                insertedIds: res.insertedIds\n            });\n        });\n    }\n}\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);\n//# sourceMappingURL=insert.js.map"]},"metadata":{},"sourceType":"script"}