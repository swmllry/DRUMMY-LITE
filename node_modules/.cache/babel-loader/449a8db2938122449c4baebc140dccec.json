{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n/** @public */\n\n\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst MAX_COMPRESSOR_ID = 3;\nconst ZSTD_COMPRESSION_LEVEL = 3; // Facilitate compressing a message using an agreed compressor\n\nfunction compress(self, dataToBeCompressed, callback) {\n  const zlibOptions = {};\n\n  switch (self.options.agreedCompressor) {\n    case 'snappy':\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.compress(dataToBeCompressed, callback);\n        } else {\n          deps_1.Snappy.compress(dataToBeCompressed).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n\n        break;\n      }\n\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n      break;\n\n    case 'zstd':\n      if ('kModuleError' in deps_1.ZStandard) {\n        return callback(deps_1.ZStandard['kModuleError']);\n      }\n\n      deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(buffer => callback(undefined, buffer), error => callback(error));\n      break;\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self.options.agreedCompressor} failed to compress`);\n  }\n}\n\nexports.compress = compress; // Decompress a message using the given compressor\n\nfunction decompress(compressorID, compressedData, callback) {\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }, callback);\n        } else {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }).then(buffer => callback(undefined, buffer), error => callback(error));\n        }\n\n        break;\n      }\n\n    case exports.Compressor.zstd:\n      {\n        if ('kModuleError' in deps_1.ZStandard) {\n          return callback(deps_1.ZStandard['kModuleError']);\n        }\n\n        deps_1.ZStandard.decompress(compressedData).then(buffer => callback(undefined, buffer), error => callback(error));\n        break;\n      }\n\n    case exports.Compressor.zlib:\n      zlib.inflate(compressedData, callback);\n      break;\n\n    default:\n      callback(undefined, compressedData);\n  }\n}\n\nexports.decompress = decompress;","map":{"version":3,"sources":["../../../src/cmap/wire_protocol/compression.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAIA;;;AACa,OAAA,CAAA,UAAA,GAAa,MAAM,CAAC,MAAP,CAAc;EACtC,IAAI,EAAE,CADgC;EAEtC,MAAM,EAAE,CAF8B;EAGtC,IAAI,EAAE,CAHgC;EAItC,IAAI,EAAE;AAJgC,CAAd,CAAb;AAaA,OAAA,CAAA,sBAAA,GAAyB,IAAI,GAAJ,CAAQ,CAC5C,WAAA,CAAA,oBAD4C,EAE5C,WAF4C,EAG5C,cAH4C,EAI5C,UAJ4C,EAK5C,cAL4C,EAM5C,YAN4C,EAO5C,YAP4C,EAQ5C,iBAR4C,EAS5C,gBAT4C,EAU5C,QAV4C,CAAR,CAAzB;AAab,MAAM,iBAAiB,GAAG,CAA1B;AACA,MAAM,sBAAsB,GAAG,CAA/B,C,CAEA;;AACA,SAAgB,QAAhB,CACE,IADF,EAEE,kBAFF,EAGE,QAHF,EAG4B;EAE1B,MAAM,WAAW,GAAG,EAApB;;EACA,QAAQ,IAAI,CAAC,OAAL,CAAa,gBAArB;IACE,KAAK,QAAL;MAAe;QACb,IAAI,kBAAkB,MAAA,CAAA,MAAtB,EAA8B;UAC5B,OAAO,QAAQ,CAAC,MAAA,CAAA,MAAA,CAAO,cAAP,CAAD,CAAf;QACD;;QAED,IAAI,MAAA,CAAA,MAAA,CAAO,MAAA,CAAA,WAAP,EAAoB,KAApB,IAA6B,CAAjC,EAAoC;UAClC,MAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,kBAAhB,EAAoC,QAApC;QACD,CAFD,MAEO;UACL,MAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,kBAAhB,EAAoC,IAApC,CACE,MAAM,IAAI,QAAQ,CAAC,SAAD,EAAY,MAAZ,CADpB,EAEE,KAAK,IAAI,QAAQ,CAAC,KAAD,CAFnB;QAID;;QACD;MACD;;IACD,KAAK,MAAL;MACE;MACA,IAAI,IAAI,CAAC,OAAL,CAAa,oBAAjB,EAAuC;QACrC,WAAW,CAAC,KAAZ,GAAoB,IAAI,CAAC,OAAL,CAAa,oBAAjC;MACD;;MACD,IAAI,CAAC,OAAL,CAAa,kBAAb,EAAiC,WAAjC,EAA8C,QAA9C;MACA;;IACF,KAAK,MAAL;MACE,IAAI,kBAAkB,MAAA,CAAA,SAAtB,EAAiC;QAC/B,OAAO,QAAQ,CAAC,MAAA,CAAA,SAAA,CAAU,cAAV,CAAD,CAAf;MACD;;MACD,MAAA,CAAA,SAAA,CAAU,QAAV,CAAmB,kBAAnB,EAAuC,sBAAvC,EAA+D,IAA/D,CACE,MAAM,IAAI,QAAQ,CAAC,SAAD,EAAY,MAAZ,CADpB,EAEE,KAAK,IAAI,QAAQ,CAAC,KAAD,CAFnB;MAIA;;IACF;MACE,MAAM,IAAI,OAAA,CAAA,yBAAJ,CACJ,sBAAsB,IAAI,CAAC,OAAL,CAAa,gBAAgB,qBAD/C,CAAN;EAjCJ;AAqCD;;AA3CD,OAAA,CAAA,QAAA,GAAA,QAAA,C,CA6CA;;AACA,SAAgB,UAAhB,CACE,YADF,EAEE,cAFF,EAGE,QAHF,EAG4B;EAE1B,IAAI,YAAY,GAAG,CAAf,IAAoB,YAAY,GAAG,iBAAvC,EAA0D;IACxD,MAAM,IAAI,OAAA,CAAA,uBAAJ,CACJ,2FAA2F,YAAY,GADnG,CAAN;EAGD;;EAED,QAAQ,YAAR;IACE,KAAK,OAAA,CAAA,UAAA,CAAW,MAAhB;MAAwB;QACtB,IAAI,kBAAkB,MAAA,CAAA,MAAtB,EAA8B;UAC5B,OAAO,QAAQ,CAAC,MAAA,CAAA,MAAA,CAAO,cAAP,CAAD,CAAf;QACD;;QAED,IAAI,MAAA,CAAA,MAAA,CAAO,MAAA,CAAA,WAAP,EAAoB,KAApB,IAA6B,CAAjC,EAAoC;UAClC,MAAA,CAAA,MAAA,CAAO,UAAP,CAAkB,cAAlB,EAAkC;YAAE,QAAQ,EAAE;UAAZ,CAAlC,EAAsD,QAAtD;QACD,CAFD,MAEO;UACL,MAAA,CAAA,MAAA,CAAO,UAAP,CAAkB,cAAlB,EAAkC;YAAE,QAAQ,EAAE;UAAZ,CAAlC,EAAsD,IAAtD,CACE,MAAM,IAAI,QAAQ,CAAC,SAAD,EAAY,MAAZ,CADpB,EAEE,KAAK,IAAI,QAAQ,CAAC,KAAD,CAFnB;QAID;;QACD;MACD;;IACD,KAAK,OAAA,CAAA,UAAA,CAAW,IAAhB;MAAsB;QACpB,IAAI,kBAAkB,MAAA,CAAA,SAAtB,EAAiC;UAC/B,OAAO,QAAQ,CAAC,MAAA,CAAA,SAAA,CAAU,cAAV,CAAD,CAAf;QACD;;QAED,MAAA,CAAA,SAAA,CAAU,UAAV,CAAqB,cAArB,EAAqC,IAArC,CACE,MAAM,IAAI,QAAQ,CAAC,SAAD,EAAY,MAAZ,CADpB,EAEE,KAAK,IAAI,QAAQ,CAAC,KAAD,CAFnB;QAIA;MACD;;IACD,KAAK,OAAA,CAAA,UAAA,CAAW,IAAhB;MACE,IAAI,CAAC,OAAL,CAAa,cAAb,EAA6B,QAA7B;MACA;;IACF;MACE,QAAQ,CAAC,SAAD,EAAY,cAAZ,CAAR;EA/BJ;AAiCD;;AA5CD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\nconst zlib = require(\"zlib\");\nconst constants_1 = require(\"../../constants\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\n/** @public */\nexports.Compressor = Object.freeze({\n    none: 0,\n    snappy: 1,\n    zlib: 2,\n    zstd: 3\n});\nexports.uncompressibleCommands = new Set([\n    constants_1.LEGACY_HELLO_COMMAND,\n    'saslStart',\n    'saslContinue',\n    'getnonce',\n    'authenticate',\n    'createUser',\n    'updateUser',\n    'copydbSaslStart',\n    'copydbgetnonce',\n    'copydb'\n]);\nconst MAX_COMPRESSOR_ID = 3;\nconst ZSTD_COMPRESSION_LEVEL = 3;\n// Facilitate compressing a message using an agreed compressor\nfunction compress(self, dataToBeCompressed, callback) {\n    const zlibOptions = {};\n    switch (self.options.agreedCompressor) {\n        case 'snappy': {\n            if ('kModuleError' in deps_1.Snappy) {\n                return callback(deps_1.Snappy['kModuleError']);\n            }\n            if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n                deps_1.Snappy.compress(dataToBeCompressed, callback);\n            }\n            else {\n                deps_1.Snappy.compress(dataToBeCompressed).then(buffer => callback(undefined, buffer), error => callback(error));\n            }\n            break;\n        }\n        case 'zlib':\n            // Determine zlibCompressionLevel\n            if (self.options.zlibCompressionLevel) {\n                zlibOptions.level = self.options.zlibCompressionLevel;\n            }\n            zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n            break;\n        case 'zstd':\n            if ('kModuleError' in deps_1.ZStandard) {\n                return callback(deps_1.ZStandard['kModuleError']);\n            }\n            deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(buffer => callback(undefined, buffer), error => callback(error));\n            break;\n        default:\n            throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${self.options.agreedCompressor} failed to compress`);\n    }\n}\nexports.compress = compress;\n// Decompress a message using the given compressor\nfunction decompress(compressorID, compressedData, callback) {\n    if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n        throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n    }\n    switch (compressorID) {\n        case exports.Compressor.snappy: {\n            if ('kModuleError' in deps_1.Snappy) {\n                return callback(deps_1.Snappy['kModuleError']);\n            }\n            if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n                deps_1.Snappy.uncompress(compressedData, { asBuffer: true }, callback);\n            }\n            else {\n                deps_1.Snappy.uncompress(compressedData, { asBuffer: true }).then(buffer => callback(undefined, buffer), error => callback(error));\n            }\n            break;\n        }\n        case exports.Compressor.zstd: {\n            if ('kModuleError' in deps_1.ZStandard) {\n                return callback(deps_1.ZStandard['kModuleError']);\n            }\n            deps_1.ZStandard.decompress(compressedData).then(buffer => callback(undefined, buffer), error => callback(error));\n            break;\n        }\n        case exports.Compressor.zlib:\n            zlib.inflate(compressedData, callback);\n            break;\n        default:\n            callback(undefined, compressedData);\n    }\n}\nexports.decompress = decompress;\n//# sourceMappingURL=compression.js.map"]},"metadata":{},"sourceType":"script"}